module modpsf
  use chm_kinds
  implicit none

  character(len=*), parameter, private :: SRCFILE = 'modpsf.src'

  ! temporary mark for deleted atoms, bonds,... in PSF
  integer, parameter :: deleted_mark = -99999999
  
contains

SUBROUTINE PATCH(COMLYN, COMLEN)
  !-----------------------------------------------------------------------
  !     Process PATCH command.
  !-----------------------------------------------------------------------
  use number
  use dimens_fcm
  use bases_fcm
  use psf
  use genpsf_m
  use rtf,only:rtfautop
  use stream
  use memory
#if KEY_MMFF==1
  use ffieldm           
#endif
  use memory
  use chutil,only:getrsn
  use string
  ! . Passed variables.
  CHARACTER(len=*) COMLYN
  INTEGER   COMLEN
  ! . Local variables.
  !RCZ 91/10/24 MXNPA = maximum number of patch atoms
  integer,allocatable,dimension(:,:) :: IATBON
  integer,allocatable,dimension(:) :: NATBON
  integer,allocatable,dimension(:) :: ISLCT
  INTEGER,PARAMETER :: MXNPA=100
  !RCZ
  character(len=8) PPRES, PPSEG
  character(len=6) PRES
  INTEGER     IPRES(MXNPA), K
  INTEGER     I 
  LOGICAL     CMPLTD, LSETIC, LSORT, LWARN, LANGLE, LPHI, QDID   
  LOGICAL     LDRUDE, LSHOW
  real(chm_real) DMASS
  !
#if KEY_MMFF==1
  LOGICAL     LMMFF
  !
  LMMFF = INDXA(COMLYN, COMLEN, 'MMFF') .GT. 0
#endif 
  !
  LSETIC = INDXA(COMLYN, COMLEN, 'SETU') .GT. 0
  LSORT  = INDXA(COMLYN, COMLEN, 'SORT') .GT. 0
  LWARN  = INDXA(COMLYN, COMLEN, 'WARN') .GT. 0
  !
  ! . Check for auto generation requests.
  LANGLE = RTFAUTOP
  LPHI   = RTFAUTOP
  IF (INDXA(COMLYN, COMLEN, 'ANGL') .GT. 0) LANGLE = .TRUE.
  IF (INDXA(COMLYN, COMLEN, 'NOAN') .GT. 0) LANGLE = .FALSE.
  IF (INDXA(COMLYN, COMLEN, 'DIHE') .GT. 0) LPHI = .TRUE.
  IF (INDXA(COMLYN, COMLEN, 'NODI') .GT. 0) LPHI = .FALSE.

      LDRUDE = (INDXA(COMLYN, COMLEN, 'DRUD') .GT. 0).or.QDRUDE
      LSHOW  = (INDXA(COMLYN, COMLEN, 'SHOW') .GT. 0)
      IF(LDRUDE)THEN
          DMASS  = GTRMF(COMLYN,COMLEN,'DMAS',0.4)
          IF(DMASS.LE.ZERO) DMASS = 0.4
          write(outu,'(1x,2A,f10.4)') &
         'Drude polarizability will be setup ', &
         'mass of Drudes particles =',DMASS
      ENDIF

  ! . Parse the residue list
  PRES = NEXTA6(COMLYN, COMLEN)
  K = 0
  CMPLTD = .TRUE.
  DO WHILE (COMLEN.GT.0 .AND. K.LT.MXNPA)
     PPSEG = NEXTA8(COMLYN, COMLEN)
     PPRES = NEXTA8(COMLYN, COMLEN)
     CALL TRIME(COMLYN, COMLEN)
     K = K + 1
     IPRES(K) = GETRSN(PPSEG, PPRES, ' ', SEGID, RESID, ATYPE, &
          IBASE, NICTOT, NSEG)
     CMPLTD = CMPLTD .AND. (IPRES(K).NE.-1)
  ENDDO
  IF(CMPLTD) THEN
     CALL PATIC(PRES, IPRES, K, LWARN, LSETIC, LSORT)
#if KEY_MMFF==1
     if(FFIELD.eq.MMFF .AND. LMMFF) call mmff_setup
#endif 
     !
     ! . Process autogenerate option (if requested)
      IF(LANGLE .OR. LPHI) THEN

           call chmalloc(SRCFILE,'PATCH','NATBON',NATOM,intg=NATBON)
           call chmalloc(SRCFILE,'PATCH','IATBON',IATBMX,natom,intg=IATBON)
           call chmalloc(SRCFILE,'PATCH','ISLCT',NATOM,intg=ISLCT)
           call filli4(islct,natom,1)

           CALL AUTGEN(1,NATBON,IATBON,ISLCT,.true.,2,LANGLE,LPHI,QDID)

           call chmdealloc(SRCFILE,'PATCH','NATBON',NATOM,intg=NATBON)
           call chmdealloc(SRCFILE,'PATCH','IATBON',IATBMX,natom,intg=IATBON)
           call chmdealloc(SRCFILE,'PATCH','ISLCT',NATOM,intg=ISLCT)

        !adm..11-Aug-2004
        IF (QDID .and. PRNLEV.GE.2) WRITE(OUTU,46)
46      FORMAT(' PATCH: Check angles and dihedrals autogenerated.')
      ENDIF


     !adm..
     ! . Print out the structure file counters.
     CALL PSFSUM(OUTU)
  ELSE
     CALL WRNDIE(-3,'<CHARMM>','Bad residue specified for patching')
  ENDIF
  !

        IF(QDRUDE) THEN

      if(prnlev.ge.5)then
      write(outu,*)
      write(outu,'(1x,a)') &
       'MKDRUDE generate list and setup for drude polarizability'
      write(outu,*)
      endif

!        DO I=1,NATOM
        DO I=2,NATOM  ! I cannot be 1, since ALPHADP(i-1)

        LDRUDE = (atype(i)(1:1).eq.'D').and. &
                 (amass(i).eq.0.0).and. &
                 (abs(ALPHADP(i-1)).ne.0.0)
        IF (LDRUDE.and..not.ISDRUDE(I)) THEN

           CALL MKDRUD(i-2,i,ATYPE,IAC,CG,AMASS,DMASS,THOLEI, &
                ALPHADP,ISDRUDE,nbond,ib,jb,NDRUDE,LSHOW)
           nbdrude=nbond
        ENDIF
        ENDDO
        ENDIF

        nbondt=nbond
        nbondt2=nbond

  RETURN
END SUBROUTINE PATCH

SUBROUTINE PATIC(PRES,IPR,NPR,LWARN,LSETIC,LSORT)
  !-----------------------------------------------------------------------
  !     General patching routine, patching data read from RTF.
  !     Deletions and addition of atoms, bonds, etc,
  !     modify atom specifications and group boundaries.
  !
  !     ORIGINAL VERSION APR-82  BRB
  !     GENERALISED VERSION 23-JAN-83 Axel Brunger
  !
  use dimens_fcm
  use psf
  use rtf,only:nrtrs, rtrtyp, nic
  !
  character(len=6) :: PRES
  INTEGER :: IPR(:), NPR
  LOGICAL   LWARN, LSETIC, LSORT
  !
  INTEGER :: alen, I
  !
  ! The following should give an estimate of needed space
  !
  alen=NATOM
  DO I=1,NRTRS
     IF (RTRTYP(I).EQ.1) THEN
        IF(I.EQ.1) THEN
           alen=alen+NIC(1,1)
        ELSE
           alen=alen+NIC(1,I)-NIC(1,I-1)+1
        ENDIF
     ENDIF
  ENDDO
  alen=MAX(MIN(alen,MAXA),NATOMT)

  CALL PATIC2(PRES,IPR,NPR,LWARN,LSETIC,LSORT,alen)
  RETURN
END SUBROUTINE PATIC

SUBROUTINE PATIC2(PRES,IPR,NPR,LWARN,LSETIC,LSORT,alen)
  !-----------------------------------------------------------------------
  !     See PATIC above.
  !
  !     23-JAN-83 Axel Brunger
  !     06-Nov-95 Jay Banks, add BondType and AtNum
  !
  use cnst_fcm, only: qcnstr, cnst_is_allocated, allocate_cnst
  use intcor_module,only: reintc_new,icr_struct
  use intcor2,only:geticel,puticel
  use dimens_fcm
  use exfunc, only: find52, order, order5
  use number
  use consta
  use aniso_fcm
  use lonepr
  use bases_fcm
  use psf
  use genpsf_m
  use rtf,only: nrtrs, aa, rtrtyp, nic, delat, ftp, mxn, mnb, mac, armass, &
    alph, thol, chg, grpr, mib, mjb, delbd, mit, mjt, mkt, &
    delan, mip, mjp, mkp, mlp, delpt, mip, mjp, mim, mjm, mkm, delmt, &
    mlp1ct, mlp2ct, mlp3ct, mlp4ct, mlp0ct, mlpct1d, rlpct, tlpct, plpct, mianis, &
    maxcent_hosts, &
    mjanis, mlm, mkanis, mlanis, a22anis, a11anis, &
    delanis, &
    mh, md, deldn, ma, maa, &
    delac, bari, barj, bark, barl, delic, bart, icb1, icb2, icth1, icth2, &
    icphi, MAUTOR, MAUTOA, MAUTOB, MAUTOT, MAUTOP
#if KEY_MMFF==1
  use rtf, only: atnumr, mbtype 
#endif
#if KEY_CMAP==1
  use rtf, only: mi1ct, mj1ct, mk1ct, ml1ct, mi2ct, mj2ct, mk2ct, ml2ct 
#endif
#if KEY_CMAP==1
  use rtf, only: delpct 
#endif
  use coord
  use coordc
  use stream
  use mmffm
  use ffieldm
  use chutil,only:getseg,atomid
  use machutil,only:die
#ifdef KEY_RESIZE
  use resize
#endif  

  character(len=*)   PRES
  INTEGER :: IPR(:), NPR
  LOGICAL   LWARN, LSETIC, LSORT
  integer :: alen
  !
  EXTERNAL EXCH, EXCH5
  integer, dimension(alen) :: SEGLST, RESLST, GRPLST, ATMLST, MAP, INVMAP
  integer, dimension(alen) :: DATOM1, DATOM2, LIBLO
  integer, dimension(NNB) :: LINB
  INTEGER   INDEX, OFFSET, PATGRP
  INTEGER GROUP,I,II,IPATC,IPT,JPT,IDELTA,K,ERRCNT
  INTEGER   J, JJ, KK, LL, NL, NDATOM, PATRES, OLDRES,OLDATM, JK, ITEMP
  INTEGER, DIMENSION(maxcent_hosts) :: IIJ   ! Dimension equal to maximum number of lone pair center hosts.
#if KEY_CMAP==1
  INTEGER II1,JJ1,KK1,LL1,II2,JJ2,KK2,LL2
  INTEGER INX1,INX2
#endif 
  LOGICAL   FOUND, QDELET, ERROR, BYPASS, QNEWRS, LW, TT
  LOGICAL OK1
  INTEGER IX 
  INTEGER IRSZ
  real(chm_real)  RX
  real(chm_real) A33
  !     Temporary mark for deleted atoms, bonds,... in PSF:
  INTEGER,PARAMETER :: MARK = -99999999
  LOGICAL :: LOK
#ifdef KEY_RESIZE
  integer na0
#endif  
  !
  !     Mark for unknown atom coordinates for added atoms:
  !
  character(len=4)   BLANK
  character(len=8)   SIDDN,RIDDN,RESDN,ATDN,PTYP
  DATA   BLANK/'    '/
  !
  LW = (WRNLEV.GE.2) .AND. (PRNLEV.GE.2)
  FOUND=.FALSE.
  DO J=1,NRTRS
     IF(PRES.EQ.AA(J)) THEN
        IF(RTRTYP(J).NE.1) THEN
           IF(WRNLEV.GE.2 .AND. PRNLEV.GE.2) WRITE(OUTU,1000) PRES
           CALL DIEWRN(-4)
        ELSE
           IPATC=J
           FOUND=.TRUE.
        ENDIF
     ENDIF
  ENDDO
1000 FORMAT(' ERROR in PATIC: Residue ',A6,' has wrong patch type.')
  IF(.NOT.FOUND) THEN
     IF(WRNLEV.GE.2 .AND. PRNLEV.GE.2) WRITE(OUTU,1010) PRES
     CALL DIEWRN(-4)
  ENDIF
1010 FORMAT(' ERROR in PATIC: Residue ',A6,' was not found.')
  !
  ! treat all image atoms as if they are deleted (for IC elements involving image atoms)
  DO I=NATOM+1, NATOMT
        MAP(I) = mark
  ENDDO
  !
  ! patch atom sequence.
  !
  ERRCNT=0
  NDATOM=0
  !
  !     Fill segment list SEGLST with values corresonding to current
  !     PSF.
  !
  DO I=1,NSEG
     DO J=NICTOT(I)+1,NICTOT(I+1)
        DO K=IBASE(J)+1,IBASE(J+1)
           SEGLST(K)=I
        ENDDO
     ENDDO
  ENDDO
  !
  ! Fill residue list RESLST with values corresponding to current PSF.
  !
  DO I=1,NRES
     DO J=IBASE(I)+1,IBASE(I+1)
        RESLST(J)=I
     ENDDO
  ENDDO
  !
  ! Fill group list GRPLST with values corresponding to current PSF
  !
  GROUP = 0
  DO I=1,NGRP
     DO J=IGPBS(I)+1,IGPBS(I+1)
        GRPLST(J)=I*(GRPR(NIC(1,IPATC))+1)*10
        ! allow 100 atoms to be inserted between existing atoms
        ATMLST(J)=J*100
     ENDDO
  ENDDO
  !
  ! Read in atoms of patch residue PRES == IPATC
  ! Prepare atom mapping (add atoms, modify GRPLST, make list
  ! of atoms to be deleted)
  !
  PATGRP=-1
  OLDRES=-1
  BYPASS=.TRUE.
  !
  IF(IPATC.GT.1) THEN
     II=NIC(1,IPATC-1)+1
  ELSE
     II=1
  ENDIF
#ifdef KEY_RESIZE
  na0=natom ! temporary counter
#endif
  DO I=II,NIC(1,IPATC)
     QDELET=DELAT(I)
     CALL PATOM(NL,PATRES,PTYP,FTP(I),ATYPE,IBASE,IPR,NPR, &
          1,NRES,.FALSE.)
     QNEWRS=.FALSE.
     IF (PATRES.NE.OLDRES) THEN
        QNEWRS=.TRUE.
        OLDRES=PATRES
        OLDATM=IBASE(PATRES+1)
     ENDIF

     IF(NL.NE.MARK .AND. QDELET) THEN
        !
        ! Atom NL is in residue PATRES and is to be deleted:
        !
        NDATOM = NDATOM + 1
        DATOM1(NDATOM) = NL
        DATOM2(NDATOM) = MARK
        BYPASS=.FALSE.
        !C
        II=0
        IF(I.GT.1) II=MXN(I-1)
        IF(MXN(I).GT.II) THEN
           II=II+1
           CALL PATOM(LL,PATRES,PTYP,MNB(II),ATYPE,IBASE,IPR,NPR, &
                1,NRES,.FALSE.)
           IF(LL.GT.0) THEN
              DATOM2(NDATOM) = LL
           ELSE
              IF(LW) WRITE(OUTU,1015) FTP(I),PRES, &
                   RES(PATRES)(1:idleng),RESID(PATRES)(1:idleng), &
                   MNB(II)
              ERRCNT=ERRCNT+1
           ENDIF
        ENDIF
1015    FORMAT(' <PATIC> Atom ',A6,' in PATCH ',A6, &
             ' is to be deleted in residue ',2A,',',/, &
             ' but the connecting atom ',A6, &
             ' is not present.  No connecting atom will be used.',/, &
             ' The COMBine option only works for atoms already', &
             ' existing atoms in the PSF.')
        !
        OLDATM=NL
        CALL ATOMID(NL,SIDDN,RIDDN,RESDN,ATDN)
        IF(PRNLEV.GE.2) WRITE(OUTU,'(a,4(1x,a),a)') &
             ' ATOM ',SIDDN(1:idleng),RIDDN(1:idleng), &
             RESDN(1:idleng),ATDN(1:idleng), &
             ' AND ALL REFERENCES TO IT DELETED.'
        !
     ELSE IF(NL.EQ.MARK .AND. QDELET) THEN
        IF(LW) THEN
           WRITE(OUTU,1020) FTP(I),PRES, &
                RES(PATRES)(1:idleng),RESID(PATRES)(1:idleng)
1020       FORMAT(' <PATIC> Atom ',A6,' in PATCH ',A6, &
                ' was to be deleted in residue ',2A, &
                ' but is not present.')
        ENDIF
        ERRCNT=ERRCNT+1
     ELSE IF(NL.NE.MARK .AND. .NOT. QDELET) THEN
        !
        ! Atom NL exists in residue PATRES, change atom specifications
        ! according to patch residue.
        !
        IAC(NL)=MAC(I)
        AMASS(NL)=ARMASS(IAC(NL))
        ALPHADP(NL)=ALPH(I)
        THOLEI(NL)=THOL(I)
        ISDRUDE(NL)=.FALSE.
        ICAAUTO(NL)=MAUTOA(I)

#if KEY_MMFF==1
        if(ffield == mmff) AtNum(NL)=AtNumR(I) 
#endif
        IF(ABS(CHG(I)).GT. NINETY) THEN
           IF(CHG(I).GT.0) THEN
              CG(NL)=CG(NL)-HUNDRD+CHG(I)
           ELSE
              CG(NL)=CG(NL)+HUNDRD+CHG(I)
           ENDIF
        ELSE
           CG(NL)=CHG(I)
        ENDIF
        OLDATM=NL
        !
        ! The following group re-assignment is bypassed if atom I in PRES
        ! has group number 0 (e.g. in old RTF files...)
        !
        IF (GRPR(I).GT.0) THEN
           IF (GRPR(I).NE.PATGRP) THEN
              PATGRP=GRPR(I)
              IF(QNEWRS) THEN
                 GROUP=GRPLST(NL)-GRPR(NIC(1,IPATC))
              ELSE
                 GROUP=GROUP+1
              ENDIF
              !
              ! This should give the correct group boundaries and residue
              ! boundaries.
              !
           ENDIF
           GRPLST(NL)=GROUP
        ENDIF
        !
     ELSE IF(NL.EQ.MARK .AND. .NOT. QDELET) THEN
        !
        ! This atom should be added.
        !
#ifndef KEY_RESIZE
        IF(NATOM+1.GT.MAXA) THEN
           CALL WRNDIE(-4,'<PATIC>','Maximum number of atoms MAXA exceeded')
        ELSE
#endif
           BYPASS=.FALSE.
           NATOM=NATOM+1
#ifdef KEY_RESIZE
           if (natom .gt. na0) then
              na0=natom+drsz0
              call resize_psf('modpsf.F90','PATIC2','NATOM',na0, .true.)
              call resize_coord('modpsf.F90','PATIC2',na0, .true.)
              call resize_coordc('modpsf.F90','PATIC2',na0, .true.)
              call resize_deriv('modpsf.F90','PATIC2',na0, .true.)
           endif
#endif    
           IAC(NATOM)=MAC(I)
           AMASS(NATOM)=ARMASS(IAC(NATOM))
#if KEY_MMFF==1
           if(ffield == mmff) AtNum(NATOM)=AtNumR(I) 
#endif
           CG(NATOM)=CHG(I)
           IF(ABS(CHG(I)).GT. NINETY) &
                CALL WRNDIE(-2,'<MODPSF>','Charge value out of range')
           ATYPE(NATOM)=PTYP
           RSCLF(NATOM)=ONE
           ICAAUTO(NATOM)=MAUTOA(I)   ! process autogen flag for this atom

#if KEY_WCA==1
           WCA(NATOM)=ONE             
#endif
           IMOVE(NATOM)=0
           RESLST(NATOM)=PATRES
           SEGLST(NATOM)=GETSEG(PATRES,NICTOT,NSEG)
           ALPHADP(NATOM)=ALPH(I)
           THOLEI(NATOM)=THOL(I)
           ISDRUDE(NATOM)=.FALSE.
           ! here no explicit nonbonded exclusions are allowed for this atom
           !
           IBLO(NATOM)=NNB
           !
           !     now, the new atom has to be to assigned to a group number
           !     the case with GRPR(I)=0 is special (e.g. old RTF files...)
           !
           IF(GRPR(I).EQ.0) THEN
              GROUP=GRPLST(OLDATM)
           ELSE
              IF (GRPR(I).NE.PATGRP) THEN
                 PATGRP=GRPR(I)
                 IF(QNEWRS) THEN
                    GROUP=GRPLST(IBASE(PATRES+1))-GRPR(NIC(1,IPATC))
                 ELSE
                    GROUP=GROUP+1
                 ENDIF
              ENDIF
              !
              !     This should give the correct group boundaries and residue
              !     boundaries.
              !
           ENDIF
#ifndef KEY_RESIZE
        ENDIF
#endif
        ATMLST(NATOM)=ATMLST(OLDATM)+1
        OLDATM=NATOM
        !
        GRPLST(NATOM)=GROUP
        !
        !     Now reset coordinates, etc. for added atom:
        !
        CALL ATMINI(NATOM,NATOM)
        !
        IF(PRNLEV.GE.2) WRITE(OUTU,'(a,4(1x,a),a)') &
             ' ATOM ',SEGID(SEGLST(NATOM))(1:idleng), &
             RES(PATRES)(1:idleng),RESID(PATRES)(1:idleng), &
             PTYP(1:idleng),' ADDED.'
     ENDIF
  ENDDO
#ifdef KEY_RESIZE
  if (natom .lt. na0) then ! shrink to fit
     call resize_psf('modpsf.F90','PATIC2','NATOM',NATOM, .true.)
     call resize_coord('modpsf.F90','PATIC2',NATOM, .true.)
     call resize_coordc('modpsf.F90','PATIC2',NATOM, .true.)
     call resize_deriv('modpsf.F90','PATIC2',NATOM, .true.)
  endif
#endif  
  !
  CALL SORT(NDATOM, EXCH5, ORDER5, DATOM1, DATOM2, (/0/), (/0/), (/0/), (/0/), (/0/), (/2/))
  !
  !C
  !      DO (I=1,NATOM)
  !      WRITE(OUTU,444) I,ATMLST(I),GRPLST(I),RESLST(I),TYPE(I)
  ! 444  FORMAT(4I5,2X,A4)
  !      FIN
  !C
  !
  !     Now define a map as well as an inverse map to map the atom
  !     numbers.
  !     First, sort GRPLST, using quicksort (SORT4P conserves the order of
  !     equal elements, this is essential at this point!)
  !
  CALL SORTP(NATOM,INVMAP,ORDER,ATMLST,1,0,0,0,0,0,0)
  DO I=1,NATOM
     MAP(INVMAP(I))=I
  ENDDO
  !
  !     account for deletions, reduce NATOM by NDATOM,
  !     deleted atoms are mapped to MARK
  !
  OFFSET=1
  DO I=1,NATOM
     IF (OFFSET.LE.NDATOM) THEN
        IF (DATOM1(OFFSET) == I) THEN
           MAP(I)=MARK
           OFFSET=OFFSET+1
        ENDIF
     ENDIF
  ENDDO
  NATOM=NATOM-NDATOM
  OFFSET=0
  DO I=1,NATOM
     DO WHILE (MAP(INVMAP(I+OFFSET)).EQ.MARK)
        OFFSET=OFFSET+1
     ENDDO
     INVMAP(I)=INVMAP(I+OFFSET)
  ENDDO
  DO I=1,NATOM
     MAP(INVMAP(I))=I
  ENDDO
  !
  DO I=1,NDATOM
     IF (DATOM2(I) /= MARK) MAP(DATOM1(I)) = MAP(DATOM2(I))
  ENDDO
  !
  !     now begin complete mapping of PSF, INTCR, COORD, COORDC, CNST
  !     note that NATOM is already reduced by the number of deleted atoms.
  !
  if (cnst_is_allocated) call allocate_cnst(natom)

  CALL MAPIC(MAP,INVMAP,SEGLST,RESLST,GRPLST,LINB,LIBLO, &
       MARK,BYPASS)
  !
  !
  !
  ! add in or delete internal coordinates using final atom sequence
  !
  ! deletion of bonds, angles, dihedrals and improper dihedrals
  ! takes account of the symmetry operations:
  ! bonds:     (a,b)<-->(b,a)
  ! angles:    (a,b,c)<-->(c,b,a)
  ! dihedrals: (a,b,c,d)<-->(d,c,b,a)
  ! impropers: (a,b,c,d)<-->(d,c,b,a)
  ! donors, acceptors and IC's have to be specified the same way as
  ! in the PSF resp. RTF.
  !
  !
  ! put in bonds
  !
  IF(IPATC.GT.1) THEN
     I=NIC(2,IPATC-1)+1
  ELSE
     I=1
  ENDIF
#ifdef KEY_RESIZE
  na0=nbond ! temporary counter
#endif  
  DO IPT=I,NIC(2,IPATC)
     ERROR=.FALSE.
     CALL PATOM(II,PATRES,PTYP,MIB(IPT),ATYPE,IBASE,IPR,NPR,1, &
          NRES,LW)
     CALL PATOM(JJ,PATRES,PTYP,MJB(IPT),ATYPE,IBASE,IPR,NPR,1, &
          NRES,LW)
     IF(II.GT.0.AND.JJ.GT.0.AND..NOT.DELBD(IPT)) THEN
            FOUND = .false.
            DO KK=1,NBOND
              IF(((II.EQ.IB(KK)).AND.(JJ.EQ.JB(KK))) .OR. &
                 ((II.EQ.JB(KK)).AND.(JJ.EQ.IB(KK))))THEN
                 FOUND = .true.
                 ICBAUTO(KK)=MAUTOB(IPT) ! save autogen flag, in case it changed
              ENDIF
            ENDDO
            IF (.not. FOUND) THEN
              NBOND=NBOND+1
#ifdef KEY_RESIZE
              if (nbond .gt. na0) then
                 na0=nbond+drsz0
                 call resize_psf('modpsf.F90','PATIC2','NBOND',na0, .true.)
              endif
#endif               
              IB(NBOND)=II
              JB(NBOND)=JJ
              ICBAUTO(NBOND)=MAUTOB(IPT)   ! process autogen flag for this bond

              IF(iand(ICAAUTO(II),96) .ne. iand(ICAAUTO(JJ),96)) THEN
                ! we are adding a bond between an atom with autogen and an atom without autogen.
                ! Let's send a benign warning, asking the user to please check their resulting PSF after autogen.
                   IF(LW) WRITE(OUTU,888) AA(IPATC),MIB(IPT),MJB(IPT)
888                FORMAT(' PATCH warning: Adding a bond between atoms with and without autogeneration of angles or dihedrals.',/ &
                          '                Please check resultant angle and dihedral PSF terms involving these atoms.',/&
                          '                Bond in patch: ',A6,'  atoms:',2(1X,'"',A6,'"'),' is created.',/) 
              ENDIF

#if KEY_MMFF==1
              if(ffield == mmff) BondType(NBOND)=MBTYPE(IPT) 
#endif
            ENDIF
     ELSE IF(II.GT.0.AND.JJ.GT.0.AND.DELBD(IPT)) THEN
        INDEX=FIND52(IB,JB,0,0,0,II,JJ,0,0,0,NBOND,2,MARK)
        IF(INDEX.EQ.MARK) INDEX=FIND52(IB,JB,0,0,0,JJ,II,0,0,0, &
             NBOND,2,MARK)
        IF(INDEX.NE.MARK) THEN
           IB(INDEX)=MARK
        ELSE
           ERROR=.TRUE.
        ENDIF
     ELSE
        ERROR=.TRUE.
     ENDIF
     IF(ERROR) THEN
        ERRCNT=ERRCNT+1
        IF(LW) WRITE(OUTU,1080) AA(IPATC),MIB(IPT),MJB(IPT)
1080    FORMAT(' ** WARNING ** BOND NOT FOUND FOR PATCH ',A6, &
             '.'/,' ATOMS',2(1X,'"',A6,'"'),' WERE REQUESTED.')
     ENDIF
  ENDDO
#ifdef KEY_RESIZE
  if (nbond .lt. na0) &
       call resize_psf('modpsf.F90','PATIC2','NBOND',nbond, .true.)
#endif  
  !
  ! put in angles
  !
  IF(IPATC.GT.1) THEN
     I=NIC(3,IPATC-1)+1
  ELSE
     I=1
  ENDIF
#ifdef KEY_RESIZE
  na0=ntheta ! temporary counter
#endif    
  DO IPT=I,NIC(3,IPATC)
     ERROR=.FALSE.
     CALL PATOM(II,PATRES,PTYP,MIT(IPT),ATYPE,IBASE,IPR,NPR,1,NRES,LW)
     CALL PATOM(JJ,PATRES,PTYP,MJT(IPT),ATYPE,IBASE,IPR,NPR,1,NRES,LW)
     CALL PATOM(KK,PATRES,PTYP,MKT(IPT),ATYPE,IBASE,IPR,NPR,1,NRES,LW)
     IF(II.GT.0.AND.JJ.GT.0.AND.KK.GT.0) THEN
       ! OK all atoms found
          IF(iand(MAUTOT(IPT),1).gt.0) THEN  ! angle autogenerate
            IF(.not.DELAN(IPT)) THEN
               ! save this specified angle for this or future autogens
              FOUND=.FALSE.
              DO JPT=1,NPAUTO
                IF((JJ.EQ.JPAUTO(JPT)).AND.(0.EQ.LPAUTO(JPT))) THEN
                  IF((II.EQ.IPAUTO(JPT)).AND.(KK.EQ.KPAUTO(JPT))) THEN
                     FOUND=.TRUE.
                     ICPAUTO(JPT)=MAUTOT(IPT) ! save autogen flag, in case it changed
                  ENDIF
                  IF((KK.EQ.IPAUTO(JPT)).AND.(II.EQ.KPAUTO(JPT))) THEN
                     FOUND=.TRUE.
                     ICPAUTO(JPT)=MAUTOT(IPT) ! save autogen flag, in case it changed
                  ENDIF
                ENDIF
              ENDDO
              IF(.not.FOUND) THEN  ! add this new angle to the autogenerate list
                  IF(NPAUTO.GE.MAXPAUTO) CALL WRNDIE(-4,'<PATIC2>','Too many autogens')
                  NPAUTO=NPAUTO+1
                  IPAUTO(NPAUTO)=II
                  JPAUTO(NPAUTO)=JJ
                  KPAUTO(NPAUTO)=KK
                  LPAUTO(NPAUTO)=0
                  ICPAUTO(NPAUTO)=MAUTOT(IPT)
              ENDIF
            ELSE
              ! If there is an active autogen, then delete it
              DO JPT=1,NPAUTO
                IF((JJ.EQ.JPAUTO(JPT)).AND.(0.EQ.LPAUTO(JPT))) THEN
                  IF((II.EQ.IPAUTO(JPT)).AND.(KK.EQ.KPAUTO(JPT))) IPAUTO(JPT)=MARK
                  IF((KK.EQ.IPAUTO(JPT)).AND.(II.EQ.KPAUTO(JPT))) IPAUTO(JPT)=MARK
                ENDIF
              ENDDO
            ENDIF
          ENDIF

            ! Now, add to or delete from the PSF.
            ! but first see if it's already there in the PSF 
            FOUND=.FALSE.
            DO JPT=1,NTHETA
              IF((JJ.EQ.JT(JPT)).AND.(((II.EQ.IT(JPT)).AND.(KK.EQ.KT(JPT))) &
                               .OR.   ((II.EQ.KT(JPT)).AND.(KK.EQ.IT(JPT))))) THEN
                 FOUND=.TRUE.

                   WRITE(OUTU,988) AA(IPATC),MIT(IPT),MJT(IPT),MKT(IPT),JPT
 988               FORMAT(' Found existing angle ',A6, &
                    '.'/,' ATOMS',3(1X,'"',A6,'"'),' as',I5)   

                 IF(DELAN(IPT)) THEN
                   IT(JPT)=MARK  
                 ELSEIF(iand(MAUTOT(IPT),1).eq.0) THEN
                   ERRCNT=ERRCNT+1
                   IF(LW) WRITE(OUTU,1088) AA(IPATC),MIT(IPT),MJT(IPT),MKT(IPT)
1088               FORMAT(' ** WARNING ** Trying to add an existing angle ',A6, &
                    '.'/,' ATOMS',3(1X,'"',A6,'"'),' WERE REQUESTED.')              
                 ENDIF
              ENDIF
            ENDDO

            IF(.not.FOUND) THEN  ! add this new angle to the psf
              IF(DELAN(IPT)) THEN
               IF(iand(MAUTOT(IPT),1).eq.0) THEN
                ERRCNT=ERRCNT+1
                IF(LW) WRITE(OUTU,1089) AA(IPATC),MIT(IPT),MJT(IPT),MKT(IPT)
1089            FORMAT(' ** WARNING ** Trying to delete an angle not found',A6, &
                    '.'/,' ATOMS',3(1X,'"',A6,'"'),' WERE REQUESTED.') 
               ENDIF   
            ELSE
#ifndef KEY_RESIZE
                 IF(NTHETA.GE.MAXT) CALL WRNDIE(-4,'<PATIC2>','Too many angles')
#endif
                NTHETA=NTHETA+1
#ifdef KEY_RESIZE
                if (ntheta .gt. na0) then
                   na0=ntheta+drsz0
                   call resize_psf('modpsf.F90','PATIC2','NTHETA',na0, .true.)
                endif
#endif  
                IT(NTHETA)=II 
                JT(NTHETA)=JJ
                KT(NTHETA)=KK
              ENDIF
            ENDIF

     ELSE
        ERRCNT=ERRCNT+1
        IF(LW) WRITE(OUTU,1090) AA(IPATC),MIT(IPT),MJT(IPT),MKT(IPT)
1090    FORMAT(' ** WARNING ** ATOMS FOR ANGLE NOT FOUND FOR PATCH ',A6, &
             '.'/,' ATOMS',3(1X,'"',A6,'"'),' WERE REQUESTED.')
     ENDIF
  ENDDO
#ifdef KEY_RESIZE
  if (ntheta .lt. na0) &
       call resize_psf('modpsf.F90','PATIC2','NTHETA',ntheta, .true.)
#endif  
  !
  ! put in dihedrals
  !
  IF(IPATC.GT.1) THEN
     I=NIC(4,IPATC-1)+1
  ELSE
     I=1
  ENDIF
#ifdef KEY_RESIZE
  na0=nphi ! temporary counter
#endif    
  DO IPT=I,NIC(4,IPATC)
     ERROR=.FALSE.
     CALL PATOM(II,PATRES,PTYP,MIP(IPT),ATYPE,IBASE,IPR,NPR,1, &
          NRES,LW)
     CALL PATOM(JJ,PATRES,PTYP,MJP(IPT),ATYPE,IBASE,IPR,NPR,1, &
          NRES,LW)
     CALL PATOM(KK,PATRES,PTYP,MKP(IPT),ATYPE,IBASE,IPR,NPR,1, &
          NRES,LW)
     CALL PATOM(LL,PATRES,PTYP,MLP(IPT),ATYPE,IBASE,IPR,NPR,1, &
          NRES,LW)
     IF(II.GT.0.AND.JJ.GT.0.AND.KK.GT.0.AND.LL.GT.0) THEN
       ! OK all atoms found
          IF(iand(MAUTOP(IPT),1).gt.0) THEN  ! dihedral RTF based autogenerate
            IF(.not.DELPT(IPT)) THEN
               ! save this specified dihedral for this or future autogens
              FOUND=.FALSE.
              DO JPT=1,NPAUTO
                IF((II.EQ.IPAUTO(JPT)).AND.(JJ.EQ.JPAUTO(JPT)).AND.(KK.EQ.KPAUTO(JPT)).AND.(LL.EQ.LPAUTO(JPT))) THEN
                   FOUND=.TRUE.
                   ICPAUTO(JPT)=MAUTOP(IPT) ! save autogen flag, in case it changed
                ENDIF
                IF((LL.EQ.IPAUTO(JPT)).AND.(KK.EQ.JPAUTO(JPT)).AND.(JJ.EQ.KPAUTO(JPT)).AND.(II.EQ.LPAUTO(JPT))) THEN
                   FOUND=.TRUE.
                   ICPAUTO(JPT)=MAUTOP(IPT) ! save autogen flag, in case it changed
                ENDIF
              ENDDO
              IF(.not.FOUND) THEN  ! add this new angle to the auto generate list
                  IF(NPAUTO.GE.MAXPAUTO) CALL WRNDIE(-4,'<PATIC2>','Too many autogens')
                  NPAUTO=NPAUTO+1
                  IPAUTO(NPAUTO)=II
                  JPAUTO(NPAUTO)=JJ
                  KPAUTO(NPAUTO)=KK
                  LPAUTO(NPAUTO)=LL
                  ICPAUTO(NPAUTO)=MAUTOP(IPT)
              ENDIF
            ELSE
              ! If there is an active autogen, then delete it
              DO JPT=1,NPAUTO
                IF((II.EQ.IPAUTO(JPT)).AND.(JJ.EQ.JPAUTO(JPT)).AND.(KK.EQ.KPAUTO(JPT)).AND.(LL.EQ.LPAUTO(JPT))) THEN
                   IPAUTO(JPT)=MARK
                ENDIF
                IF((LL.EQ.IPAUTO(JPT)).AND.(KK.EQ.JPAUTO(JPT)).AND.(JJ.EQ.KPAUTO(JPT)).AND.(II.EQ.LPAUTO(JPT))) THEN
                   IPAUTO(JPT)=MARK
                ENDIF
              ENDDO
            ENDIF
          ENDIF
     
            ! Now, Simply add to or delete from the PSF.
            ! but first see if it's already there in the PSF 
            FOUND=.FALSE.
            DO JPT=1,NPHI
              IF(((II.EQ.IP(JPT)).AND.(JJ.EQ.JP(JPT)).AND.(KK.EQ.KP(JPT)).AND.(LL.EQ.LP(JPT))) .OR. &
                 ((LL.EQ.IP(JPT)).AND.(KK.EQ.JP(JPT)).AND.(JJ.EQ.KP(JPT)).AND.(II.EQ.LP(JPT)))) THEN
                    FOUND=.TRUE.
                    IF(DELPT(IPT)) THEN
                      IP(JPT)=MARK  
                    ELSEIF(iand(MAUTOP(IPT),1).eq.0) THEN 
                      ERRCNT=ERRCNT+1
                      IF(LW) WRITE(OUTU,1098) AA(IPATC),MIP(IPT),MJP(IPT),MKP(IPT),MLP(IPT)
1098                  FORMAT(' ** WARNING ** Trying to add an existing dihedral ',A6, &
                        '.'/,' ATOMS',4(1X,'"',A6,'"'),' WERE REQUESTED.')              
                    ENDIF
              ENDIF
            ENDDO

            IF(.not.FOUND) THEN  ! add this new dihedral to the psf
              IF(DELPT(IPT)) THEN
               IF(iand(MAUTOP(IPT),1).eq.0) THEN 
                ERRCNT=ERRCNT+1
                IF(LW) WRITE(OUTU,1099) AA(IPATC),MIP(IPT),MJP(IPT),MKP(IPT),MLP(IPT)
1099            FORMAT(' ** WARNING ** Trying to delete an a dihedral not found',A6, &
                    '.'/,' ATOMS',4(1X,'"',A6,'"'),' WERE REQUESTED.')  
               ENDIF  
              ELSE
#ifndef KEY_RESIZE
                IF(NPHI.GE.MAXP) CALL WRNDIE(-4,'<PATIC2>','Too many dihedrals')
#endif                 
                NPHI=NPHI+1
#ifdef KEY_RESIZE
                if ( nphi .gt. na0) then
                   na0=nphi+drsz0
                   call resize_psf('modpsf.F90','PATIC2','NPHI',na0, .true.)
                endif
#endif  
                IP(NPHI)=II 
                JP(NPHI)=JJ
                KP(NPHI)=KK
                LP(NPHI)=LL
              ENDIF
            ENDIF

     ELSE
        ERRCNT=ERRCNT+1
        IF(LW) WRITE(OUTU,1100) AA(IPATC),MIP(IPT),MJP(IPT),MKP(IPT),MLP(IPT)
1100    FORMAT(' ** WARNING ** ATOMS FOR DIHEDRAL NOT FOUND FOR PATCH ',A6, &
             '.'/,' ATOMS',4(1X,'"',A6,'"'),' WERE REQUESTED.')
     ENDIF
  ENDDO
#ifdef KEY_RESIZE
  if (nphi .lt. na0) &
       call resize_psf('modpsf.F90','PATIC2','NPHI',nphi, .true.)
#endif  
  !
  ! put in improper dihedrals
  !
  IF(IPATC.GT.1) THEN
     I=NIC(5,IPATC-1)+1
  ELSE
     I=1
  ENDIF
#ifdef KEY_RESIZE
  na0=nimphi ! temporary counter
#endif    
  DO IPT=I,NIC(5,IPATC)
     ERROR=.FALSE.
     CALL PATOM(II,PATRES,PTYP,MIM(IPT),ATYPE,IBASE,IPR,NPR,1, &
          NRES,LW)
     CALL PATOM(JJ,PATRES,PTYP,MJM(IPT),ATYPE,IBASE,IPR,NPR,1, &
          NRES,LW)
     CALL PATOM(KK,PATRES,PTYP,MKM(IPT),ATYPE,IBASE,IPR,NPR,1, &
          NRES,LW)
     CALL PATOM(LL,PATRES,PTYP,MLM(IPT),ATYPE,IBASE,IPR,NPR,1, &
          NRES,LW)
     IF(II.GT.0.AND.JJ.GT.0.AND.KK.GT.0.AND.LL.GT.0.AND. &
          .NOT.DELMT(IPT)) THEN
        NIMPHI=NIMPHI+1
#ifdef KEY_RESIZE
        if ( nimphi .gt. na0) then
           na0=nimphi+drsz0
           call resize_psf('modpsf.F90','PATIC2','NIMPHI',na0, .true.)
        endif
#endif  
        IM(NIMPHI)=II
        JM(NIMPHI)=JJ
        KM(NIMPHI)=KK
        LM(NIMPHI)=LL
     ELSE IF(II.GT.0.AND.JJ.GT.0.AND.KK.GT.0.AND.LL.GT.0.AND. &
          DELMT(IPT)) THEN
        INDEX=FIND52(IM,JM,KM,LM,0,II,JJ,KK,LL,0,NIMPHI,4,MARK)
        IF (INDEX.EQ.MARK) &
             INDEX=FIND52(IM,JM,KM,LM,0,LL,KK,JJ,II,0,NIMPHI,4,MARK)
        IF(INDEX.NE.MARK) THEN
           IM(INDEX)=MARK
        ELSE
           ERROR=.TRUE.
        ENDIF
     ELSE
        ERROR=.TRUE.
     ENDIF
     IF (ERROR) THEN
        ERRCNT=ERRCNT+1
        IF(LW) WRITE(OUTU,1120) AA(IPATC),MIM(IPT),MJM(IPT), &
             MKM(IPT),MLM(IPT)
1120    FORMAT(' ** WARNING ** IMPROPER NOT FOUND FOR PATCH ',A6, &
             '.'/,' ATOMS',4(1X,'"',A6,'"'),' WERE REQUESTED.')
     ENDIF
  ENDDO
#ifdef KEY_RESIZE
  if (nimphi .lt. na0) &
       call resize_psf('modpsf.F90','PATIC2','NIMPHI',nimphi, .true.)
#endif  

#if KEY_LONEPAIR==1
      IF(IPATC.GT.1) THEN
         I=NIC(12,IPATC-1)+1
      ELSE
         I=1
      ENDIF
      DO IPT=I,NIC(12,IPATC)
         CALL PATOM(II,PATRES,PTYP,MLP1CT(IPT),ATYPE,IBASE,IPR,NPR,1, &
                    NRES,LW)
         CALL PATOM(JJ,PATRES,PTYP,MLP2CT(IPT),ATYPE,IBASE,IPR,NPR,1, &
                    NRES,LW)
         CALL PATOM(KK,PATRES,PTYP,MLP3CT(IPT),ATYPE,IBASE,IPR,NPR,1, &
                    NRES,LW)
         CALL PATOM(LL,PATRES,PTYP,MLP4CT(IPT),ATYPE,IBASE,IPR,NPR,1, &
                    NRES,LW)
         
         LOK=.FALSE.
         J=1
         DO WHILE (MLPCT1D((IPT-1)*MAXCENT_HOSTS+J)/=BLANK)
            CALL PATOM(IIJ(J),PATRES,PTYP,MLPCT1D((IPT-1)*MAXCENT_HOSTS+J),ATYPE,IBASE,IPR,NPR,1,NRES,LW)
            LOK=(IIJ(J).GT.0)
            J=J+1
         END DO

         IF(II.GT.0.AND.JJ.GT.0.AND.KK.GT.0.AND.LL.GT.0.OR.LOK) THEN
           if(.not.allocated(lpnhost)) call allocate_lonepair
           IF (MLP0CT(IPT)(1:3).eq.'CEN') THEN                    
              NUMLP = NUMLP + 1                                    
              LPHPTR(NUMLP) = NUMLPH + 1                           
              NUMLPH = NUMLPH + J - 1                              
              LPNHOST(NUMLP)   = J - 2                             
              DO JK = 1, J-1                                  
                 LPHOST(LPHPTR(NUMLP)+(JK-1))   = IIJ(JK)          
              ENDDO                                               
              LPWGHT(NUMLP) = (MLP0CT(IPT)(4:4).eq.'M') ! 'CENM' type                               
              LPVALUE(1,NUMLP) = RLPCT(IPT)                        
              LPVALUE(2,NUMLP) = TLPCT(IPT)                        
              LPVALUE(3,NUMLP) = PLPCT(IPT)                        
              JK=IIJ(1)                                            
              IMOVE(JK) = -1                                       
           ELSEIF((MLP0CT(IPT).eq.'RELA').or.(MLP0CT(IPT).eq.'BISE'))THEN
              NUMLP = NUMLP + 1
              LPHPTR(NUMLP) = NUMLPH + 1
              NUMLPH = NUMLPH + 4
              LPNHOST(NUMLP)   = 3
              LPHOST(LPHPTR(NUMLP))   = II
              LPHOST(LPHPTR(NUMLP)+1) = JJ
              LPHOST(LPHPTR(NUMLP)+2) = KK
              LPHOST(LPHPTR(NUMLP)+3) = LL
              LPWGHT(NUMLP) = .FALSE.
              LPVALUE(1,NUMLP) = RLPCT(IPT)
              IF(MLP0CT(IPT).eq.'BISE') THEN
                  LPVALUE(1,NUMLP) = -RLPCT(IPT)
              ENDIF ! RELATI and BISECT differ only in RLPCT
              LPVALUE(2,NUMLP) = TLPCT(IPT)
              LPVALUE(3,NUMLP) = PLPCT(IPT)
              IMOVE(II) = -1
           ELSEIF((MLP0CT(IPT).eq.'COLI')) THEN
              NUMLP = NUMLP + 1
              LPHPTR(NUMLP) = NUMLPH + 1
              NUMLPH = NUMLPH + 3
              LPNHOST(NUMLP)   = 2
              LPHOST(LPHPTR(NUMLP))   = II
              LPHOST(LPHPTR(NUMLP)+1) = JJ
              LPHOST(LPHPTR(NUMLP)+2) = KK
              LPWGHT(NUMLP) = .FALSE.
              LPVALUE(1,NUMLP) = RLPCT(IPT)
              LPVALUE(2,NUMLP) = TLPCT(IPT)      
              IMOVE(II) = -1 
           ELSE
            CALL WRNDIE(-4,'<PATIC2>','Unknown lone pair type')
           ENDIF
         ELSE
            CALL WRNDIE(-4,'<PATIC2>','lone pair not found')
         ENDIF
      ENDDO
      J=0   ! Reinitialize
      IF(IPATC.GT.1) THEN
         I=NIC(13,IPATC-1)+1
      ELSE
         I=1
      ENDIF
      DO IPT=I,NIC(13,IPATC)
         CALL PATOM(II,PATRES,PTYP,MIANIS(IPT),ATYPE,IBASE,IPR,NPR,1, &
                    NRES,LW)
         CALL PATOM(JJ,PATRES,PTYP,MJANIS(IPT),ATYPE,IBASE,IPR,NPR,1, &
                    NRES,LW)
         CALL PATOM(KK,PATRES,PTYP,MKANIS(IPT),ATYPE,IBASE,IPR,NPR,1, &
                    NRES,LW)
         CALL PATOM(LL,PATRES,PTYP,MLANIS(IPT),ATYPE,IBASE,IPR,NPR,1, &
                    NRES,LW)

         IF(II.GT.0.AND.JJ.GT.0.AND.KK.GT.0.AND.LL.GT.0) THEN
          IF(.NOT.DELANIS(IPT)) THEN
           IF( (A11ANIS(IPT).ne.ZERO).and. &
               (A22ANIS(IPT).ne.ZERO) ) THEN
              NANISO = NANISO + 1
              LSTANI1(NANISO) = II
              LSTANI2(NANISO) = JJ
              LSTANI3(NANISO) = KK
              LSTANI4(NANISO) = LL
              A33 = THREE-A11ANIS(IPT)-A22ANIS(IPT)
              IF(A33.le.ZERO) CALL WRNDIE(5,'<PATIC2>','ANISO: A33 negative ')

              K11(NANISO) = ONE/A11ANIS(IPT)
              K22(NANISO) = ONE/A22ANIS(IPT)
              K33(NANISO) = ONE/A33

              if(PRNLEV.GE.8)then
                write(*,'(1x,a,5i6,3f10.3)') &
               'Add anisotropy for one atom: ', &
                naniso,ii,jj,kk,ll, &
                K11(NANISO),K22(NANISO),K33(NANISO)
              endif
           ELSE
            CALL WRNDIE(-4,'<PATIC2>','Zero aniso force constant')
           ENDIF
          ELSE ! delete anisotropy, HJ 
            DO J=1,NANISO
             IF((LSTANI1(J).eq.II).and.(LSTANI2(J).eq.JJ).and.(LSTANI3(J).eq.KK).and.(LSTANI4(J).eq.LL)) THEN
                 if(PRNLEV.GE.8)then
                  write(*,'(1x,a,5i6,3f10.3)') &
                 'delete anisotropy for one atom: ', &
                  J,ii,jj,kk,ll, &
                  K11(J),K22(J),K33(J)
                endif
               DO K=J+1,NANISO
                  LSTANI1(K-1) = LSTANI1(K)
                  LSTANI2(K-1) = LSTANI2(K)
                  LSTANI3(K-1) = LSTANI3(K)
                  LSTANI4(K-1) = LSTANI4(K)
                  K11(K-1) = K11(K)
                  K22(K-1) = K22(K)
                  K33(K-1) = K33(K)
                ENDDO
                NANISO = NANISO - 1   
              ENDIF
            ENDDO
          ENDIF
         ENDIF
      ENDDO
#endif 
#if KEY_CMAP==1
  !
  ! put in cross-term maps
  !
  IF(IPATC.GT.1) THEN
     I=NIC(11,IPATC-1)+1
  ELSE
     I=1
  ENDIF
#ifdef KEY_RESIZE
  na0=ncrterm ! temporary counter
#endif    
  DO IPT=I,NIC(11,IPATC)
     ERROR=.FALSE.
     CALL PATOM(II1,PATRES,PTYP,MI1CT(IPT),ATYPE,IBASE,IPR, &
          NPR,1,NRES,LW)
     CALL PATOM(JJ1,PATRES,PTYP,MJ1CT(IPT),ATYPE,IBASE,IPR, &
          NPR,1,NRES,LW)
     CALL PATOM(KK1,PATRES,PTYP,MK1CT(IPT),ATYPE,IBASE,IPR, &
          NPR,1,NRES,LW)
     CALL PATOM(LL1,PATRES,PTYP,ML1CT(IPT),ATYPE,IBASE,IPR, &
          NPR,1,NRES,LW)
     CALL PATOM(II2,PATRES,PTYP,MI2CT(IPT),ATYPE,IBASE,IPR, &
          NPR,1,NRES,LW)
     CALL PATOM(JJ2,PATRES,PTYP,MJ2CT(IPT),ATYPE,IBASE,IPR, &
          NPR,1,NRES,LW)
     CALL PATOM(KK2,PATRES,PTYP,MK2CT(IPT),ATYPE,IBASE,IPR, &
          NPR,1,NRES,LW)
     CALL PATOM(LL2,PATRES,PTYP,ML2CT(IPT),ATYPE,IBASE,IPR, &
          NPR,1,NRES,LW)

     IF(  II1.GT.0.AND.JJ1.GT.0.AND.KK1.GT.0.AND.LL1.GT.0 &
          .AND.II2.GT.0.AND.JJ2.GT.0.AND.KK2.GT.0.AND.LL2.GT.0) THEN
        IF (.NOT.DELPCT(IPT)) THEN
           NCRTERM=NCRTERM+1
#ifdef KEY_RESIZE
           if ( ncrterm .gt. na0) then
              na0=ncrterm+drsz0
              call resize_psf('modpsf.F90','PATIC2','NCRTERM',na0, .true.)
           endif
#endif  
           I1CT(NCRTERM)=II1
           J1CT(NCRTERM)=JJ1
           K1CT(NCRTERM)=KK1
           L1CT(NCRTERM)=LL1
           I2CT(NCRTERM)=II2
           J2CT(NCRTERM)=JJ2
           K2CT(NCRTERM)=KK2
           L2CT(NCRTERM)=LL2
        ELSE
           INX1=FIND52(I1CT,J1CT,K1CT,L1CT,0, &
                II1,JJ1,KK1,LL1,0,NCRTERM,4,MARK)
           IF (INX1.EQ.MARK) &
                INX1=FIND52(I1CT,J1CT,K1CT,L1CT,0, &
                LL1,KK1,JJ1,II1,0,NCRTERM,4,MARK)

           INX2=FIND52(I2CT,J2CT,K2CT,L2CT,0, &
                II2,JJ2,KK2,LL2,0,NCRTERM,4,MARK)
           IF (INX2.EQ.MARK) &
                INX2=FIND52(I2CT,J2CT,K2CT,L2CT,0, &
                LL2,KK2,JJ2,II2,0,NCRTERM,4,MARK)

           IF(INX1.NE.MARK) THEN
              I1CT(INDEX)=MARK
              IF (INX2.NE.MARK) THEN
                 I2CT(INDEX)=MARK
              ELSE
                 ERROR=.TRUE.
              ENDIF
           ELSE
              ERROR=.TRUE.
           ENDIF
        ENDIF
     ELSE
        ERROR=.TRUE.
     ENDIF

     IF (ERROR) THEN
        ERRCNT=ERRCNT+1
        IF(LW) WRITE(OUTU,1121) AA(IPATC),MI1CT(IPT),MJ1CT(IPT), &
             MK1CT(IPT),ML1CT(IPT), &
             MI2CT(IPT),MJ2CT(IPT), &
             MK2CT(IPT),ML2CT(IPT)
1121    FORMAT(' ** WARNING ** CROSSTERM NOT FOUND FOR PATCH ', &
             A6, &
             '.'/,' ATOMS',4(1X,'"',A6,'"'), &
             /,' ATOMS',4(1X,'"',A6,'"'), &
             ' WERE REQUESTED.')
     ENDIF
  ENDDO
#ifdef KEY_RESIZE
  if (ncrterm .lt. na0) &
       call resize_psf('modpsf.F90','PATIC2','NCRTERM',ncrterm, .true.)
#endif  
#endif 

  !
  ! put in donors
  !
  IF(IPATC.GT.1) THEN
     I=NIC(7,IPATC-1)+1
  ELSE
     I=1
  ENDIF
#ifdef KEY_RESIZE
  na0=ndon ! temporary counter
#endif    
  DO IPT=I,NIC(7,IPATC)
     ERROR=.FALSE.
     CALL PATOM(II,PATRES,PTYP,MH(IPT),ATYPE,IBASE,IPR,NPR,1, &
          NRES,LW)
     CALL PATOM(JJ,PATRES,PTYP,MD(IPT),ATYPE,IBASE,IPR,NPR,1, &
          NRES,LW)
     IF(II.EQ.MARK) II=0
     IF(JJ.GT.0.AND.(II.GT.0.OR.MH(IPT).EQ.BLANK).AND. &
          .NOT.DELDN(IPT)) THEN
        NDON=NDON+1
#ifdef KEY_RESIZE
        if ( NDON .gt. na0) then
           na0=NDON+drsz0
           call resize_psf('modpsf.F90','PATIC2','NDON',na0, .true.)
        endif
#endif  
        IHD1(NDON)=II
        IDON(NDON)=JJ
     ELSE IF(JJ.GT.0.AND.(II.GT.0.OR.MH(IPT).EQ.BLANK).AND. &
          DELDN(IPT)) THEN
        INDEX=FIND52(IDON,IHD1,0,0,0,JJ,II,0,0,0,NDON,2,MARK)
        IF(INDEX.NE.MARK) THEN
           IDON(INDEX)=MARK
        ELSE
           ERROR=.TRUE.
        ENDIF
     ELSE
        ERROR=.TRUE.
     ENDIF
     IF (ERROR) THEN
        ERRCNT=ERRCNT+1
        IF(LW) WRITE(OUTU,1130) AA(IPATC),MH(IPT),MD(IPT)
1130    FORMAT(' ** WARNING ** DONOR NOT FOUND FOR PATCH ',A6, &
             '.'/,' ATOMS',2(1X,'"',A6,'"'),' WERE REQUESTED.')
     ENDIF
  ENDDO
#ifdef KEY_RESIZE
  if (natom .lt. na0) & ! set to natom
       call resize_psf('modpsf.F90','PATIC2','NDON',natom, .true.)
#endif  
  !
  !     put in acceptors
  !
  IF(IPATC.GT.1) THEN
     I=NIC(8,IPATC-1)+1
  ELSE
     I=1
  ENDIF
#ifdef KEY_RESIZE
  na0=NACC ! temporary counter
#endif    
  DO IPT=I,NIC(8,IPATC)
     ERROR=.FALSE.
     CALL PATOM(II,PATRES,PTYP,MA(IPT),ATYPE,IBASE,IPR,NPR,1, &
          NRES,LW)
     CALL PATOM(JJ,PATRES,PTYP,MAA(IPT),ATYPE,IBASE,IPR,NPR,1, &
          NRES,LW)
     IF(JJ.EQ.MARK) JJ=0
     IF(II.GT.0.AND..NOT.DELAC(IPT)) THEN
        NACC=NACC+1
#ifdef KEY_RESIZE
        if ( NACC .gt. na0) then
           na0=NACC+drsz0
           call resize_psf('modpsf.F90','PATIC2','NACC',na0, .true.)
        endif
#endif  
        IACC(NACC)=II
        IAC1(NACC)=JJ
     ELSE IF(II.GT.0.AND.DELAC(IPT)) THEN
        INDEX=FIND52(IACC,IAC1,0,0,0,II,JJ,0,0,0,NACC,2,MARK)
        IF(INDEX.NE.MARK) THEN
           IACC(INDEX)=MARK
        ELSE
           ERROR=.TRUE.
        ENDIF
     ELSE
        ERROR=.TRUE.
     ENDIF
     IF(ERROR) THEN
        ERRCNT=ERRCNT+1
        IF(LW) WRITE(OUTU,1140) AA(IPATC),MA(IPT),MAA(IPT)
1140    FORMAT(' ** WARNING ** ACCEPTOR NOT FOUND FOR PATCH ',A6, &
             '.'/,' ATOMS',2(1X,'"',A6,'"'),' WERE REQUESTED.')
     ENDIF
  ENDDO
#ifdef KEY_RESIZE
  if (natom .lt. na0) & ! set to natom
       call resize_psf('modpsf.F90','PATIC2','NACC',natom, .true.)
#endif  
  !
  ! put in build/ic elements
  !
  IF(LSETIC) THEN
     IF(IPATC.GT.1) THEN
        I=NIC(9,IPATC-1)+1
     ELSE
        I=1
     ENDIF
     DO IPT=I,NIC(9,IPATC)
        ERROR=.FALSE.
        CALL PATOM(II,PATRES,PTYP,BARI(IPT),ATYPE,IBASE,IPR,NPR,1, &
             NRES,LW)
        CALL PATOM(JJ,PATRES,PTYP,BARJ(IPT),ATYPE,IBASE,IPR,NPR,1, &
             NRES,LW)
        CALL PATOM(KK,PATRES,PTYP,BARK(IPT),ATYPE,IBASE,IPR,NPR,1, &
             NRES,LW)
        CALL PATOM(LL,PATRES,PTYP,BARL(IPT),ATYPE,IBASE,IPR,NPR,1, &
             NRES,LW)
        IF(II.GT.0.OR.JJ.GT.0.OR.KK.GT.0.OR.LL.GT.0) THEN
           ! passing unallocated arrays in for arrays not marked allocated
           ! is not standard fortran
           if (.not. allocated(icr_struct%iar)) then
              index = mark
           else
              INDEX=FIND52(icr_struct%IAR,icr_struct%JAR,  &
                 icr_struct%KAR,icr_struct%LAR, &
                 0,II,JJ,KK,LL,0,&
                 icr_struct%lenic,4,MARK)
           end if
           IF(.NOT.DELIC(IPT)) THEN
              !
              ! first check if that IC table entry already exists
              !
              IF(INDEX.NE.MARK) THEN
                 CALL GETICEL(II,JJ,KK,LL,TT,RX,RX,RX,RX,RX,INDEX, &
                      icr_struct%B1ic,icr_struct%B2ic, &
                      icr_struct%T1ic,icr_struct%T2ic, &
                      icr_struct%PIC, icr_struct%IAR, &
                      icr_struct%JAR, icr_struct%KAR, &
                      icr_struct%LAR, icr_struct%TAR)
                 IF(BART(IPT).NEQV.TT) INDEX=MARK
              ENDIF
              IF(INDEX.EQ.MARK) THEN
                 IF(icr_struct%intlen.LE.icr_struct%lenic) THEN  ! get more space...
                    IRSZ=icr_struct%lenic+200

                    CALL REINTC_NEW(IRSZ,icr_struct)
                 ENDIF
                 icr_struct%lenic=icr_struct%lenic+1
                 INDEX=icr_struct%lenic
              ENDIF
           ELSE
              IF(INDEX.NE.MARK) THEN
                 II=MARK
                 JJ=MARK
                 KK=MARK
                 LL=MARK
              ELSE
                 ERROR=.TRUE.
              ENDIF
           ENDIF
        ELSE
           ERROR=.TRUE.
        ENDIF
        IF(ERROR) THEN
           ERRCNT=ERRCNT+1
           IF(LW) WRITE(OUTU,1150)AA(IPATC),BARI(IPT), &
                BARJ(IPT),BARK(IPT),BARL(IPT)
1150       FORMAT(' ** WARNING ** IC NOT FOUND FOR PATCH ',A6, &
                '.'/,' ATOMS',4(1X,'"',A6,'"'),' WERE REQUESTED.')
        ELSE
           CALL PUTICEL(II,JJ,KK,LL,BART(IPT),ICB1(IPT),ICB2(IPT), &
                ICTH1(IPT),ICTH2(IPT),ICPHI(IPT),INDEX, &
                icr_struct%B1ic,icr_struct%B2ic, &
                icr_struct%T1ic,icr_struct%T2ic, &
                icr_struct%PIC, icr_struct%IAR, &
                icr_struct%JAR, icr_struct%KAR, &
                icr_struct%LAR, icr_struct%TAR)
        ENDIF
     ENDDO
  ENDIF
  !
  !     remove all internal coordinates containing MARK
  !
  CALL CMPRIC(MARK,LSORT)
  !
  !     add in explicit nonbonded exclusions if present.
  !
  IF(IPATC.GT.1) THEN
     II=NIC(1,IPATC-1)+1
  ELSE
     II=1
  ENDIF
#ifdef KEY_RESIZE
  na0=NNB ! temporary counter
#endif    
  DO J=II,NIC(1,IPATC)
     QDELET=DELAT(J)
     !
     IF(J.GT.1) THEN
        LL=MXN(J-1)
     ELSE
        LL=0
     ENDIF
     IF(LL.LT.MXN(J) .AND. .NOT.QDELET) THEN
        CALL PATOM(JJ,PATRES,PTYP,FTP(J),ATYPE,IBASE,IPR,NPR, &
             1,NRES,.FALSE.)
        IF(JJ.EQ.MARK) CALL DIE
        !        remove all previous exclusions for this atom
        IF(JJ.GT.1) THEN
           IDELTA=(IBLO(JJ)-IBLO(JJ-1))
        ELSE
           IDELTA=IBLO(JJ)
        ENDIF
        IF(IDELTA.GT.0) THEN
           NNB=NNB-IDELTA
           DO IPT=JJ,NATOM
              IBLO(IPT)=IBLO(IPT)-IDELTA
           ENDDO
           DO IPT=IBLO(JJ)+1,NNB
              INB(IPT)=INB(IPT+IDELTA)
           ENDDO
#ifdef KEY_RESIZE
           if (( NNB .gt. na0) .and. (nnb .gt. natom/2)) then ! hwm: check
              na0=NNB+drsz0
              call resize_psf('modpsf.F90','PATIC2','NNB',na0, .true.)
           endif
#endif
        ENDIF
        !
        ! add in new pairs
        DO K=LL+1,MXN(J)
           CALL PATOM(KK,PATRES,PTYP,MNB(K),ATYPE,IBASE,IPR,NPR,1, &
                NRES,LW)
           IF(KK.EQ.MARK) THEN
              ERRCNT=ERRCNT+1
              IF(LW) WRITE(OUTU,1160) AA(IPATC),MNB(K)
1160          FORMAT(' ** WARNING ** EXCLUSION NOT FOUND FOR PATCH ' &
                   ,A6,'.'/,' ATOM',1X,'"',A6,'" WAS REQUESTED.')
#ifndef KEY_RESIZE
           ELSE IF(NNB.GE.MAXNB) THEN
              CALL WRNDIE(-2,'<PATIC2>','Maximum number of exclusions exceeded')
#endif              
           ELSE
              NNB=NNB+1
#ifdef KEY_RESIZE
              if (( NNB .gt. na0) .and. (nnb .gt. natom/2)) then ! hwm: check
                 na0=NNB+drsz0
                 call resize_psf('modpsf.F90','PATIC2','NNB',na0, .true.)
              endif
#endif
              DO IPT=JJ,NATOM
                 IBLO(IPT)=IBLO(IPT)+1
              ENDDO
              DO IPT=NNB,IBLO(JJ)+1,-1
                 INB(IPT)=INB(IPT-1)
              ENDDO
              INB(IBLO(JJ))=KK
           ENDIF
        ENDDO
     ENDIF
  ENDDO
#ifdef KEY_RESIZE
  if ((NNB .lt. na0) .and. (nnb .gt. natom/2)) &
       call resize_psf('modpsf.F90','PATIC2','NNB',NNB, .true.)
#endif  
  !
  IF(ERRCNT.GT.0) THEN
     IF(LW) WRITE(OUTU,432) ERRCNT
432  FORMAT(' There were a total of',I5,' errors found for this patch')
     IF(LWARN) THEN
        CALL DIEWRN(1)
     ELSE
        CALL DIEWRN(-3)
     ENDIF
  ENDIF
  !
  RETURN
  !
END SUBROUTINE PATIC2

SUBROUTINE DELTIC(COMLYN,COMLEN)
  !-----------------------------------------------------------------------
  !     Process DELETION command.
  !
  use psf
  use stream

  character(len=*) COMLYN
  INTEGER COMLEN

  IF (NATOM <= 0) RETURN

  CALL DELTI2(COMLYN, COMLEN)

  ! . Print out the structure file counters.
  CALL PSFSUM(OUTU)
  !
  RETURN
END SUBROUTINE DELTIC

SUBROUTINE DELTI2(COMLYN, COMLEN)
  !-----------------------------------------------------------------------
  !     Routine deletes atoms and all references to atoms
  !     in PSF, CNST, COORD, COORDC and INTCR.
  !
  !     Syntax:
  !
  !     DELEte [SORT] <atom-selection-syntax>
  !
  !     If SORT is referenced the bond, angle,... lists are sorted after
  !     compression.
  !
  !     23-JAN-83 AB

  use coord, only: x, y, z, wmain
  use psf, only: natom, nbond, nbondt, nbondt2
  use select, only: selcta, selctd
  use string, only: indxa, nexta4

  ! args
  character(len=*) :: comlyn
  integer :: comlen

  ! locals
  character(len=4) :: wrd
  integer :: islct(natom), jslct(natom)
  logical :: lsort, err, cleanup, qall

  LSORT = INDXA(COMLYN, COMLEN, 'SORT') .GT. 0
  WRD = NEXTA4(COMLYN, COMLEN)
  
  IF (WRD .EQ. 'ATOM') THEN
     CALL SELCTA(COMLYN, COMLEN, ISLCT, X, Y, Z, WMAIN, .TRUE.)
  ELSE
     CALL SELCTD(COMLYN, COMLEN, ISLCT, JSLCT, X, Y, Z, WMAIN, .TRUE., ERR)
     IF (ERR) RETURN
  ENDIF
  QALL = INDXA(COMLYN, COMLEN, 'ALL') .GT. 0

  cleanup = .true.
  select case (wrd)
  case ('ATOM')
     call delete_atoms(islct, lsort, cleanup)
  case ('BOND')
     call delete_bonds(islct, jslct, lsort, qall, cleanup)
  case ('ANGL')
     call delete_angles(islct, jslct, lsort, qall, cleanup)
  case ('DIHE')
     call delete_dihedrals(islct, jslct, lsort, qall, cleanup)
  case ('AUTO')
     call delete_autogens(islct, jslct, lsort, qall, cleanup)
  case ('IMPR')
     call delete_impropers(islct, jslct, lsort, qall, cleanup)
  case ('CMAP')
     call delete_cmaps(islct, jslct, lsort, qall, cleanup)
  case ('CONN')
     call delete_connectivity(islct, jslct, lsort, qall)
  case default
     CALL WRNDIE(0,'<DELTIC>', &
          'Unrecognized DELEte option. Nothing done.')
  end select

  nbondt=nbond
  nbondt2=nbond

END SUBROUTINE DELTI2

subroutine delete_connectivity(islct, jslct, lsort, qall)
  use psf, only: natom, qdrude, nbdrude, nbond

  implicit none

  ! args
  integer :: islct(natom), jslct(natom)
  logical :: lsort, qall

  ! locals
  logical :: cleanup

  cleanup = .false.
  call delete_bonds(islct, jslct, lsort, qall, cleanup)
  call delete_angles(islct, jslct, lsort, qall, cleanup)
  call delete_dihedrals(islct, jslct, lsort, qall, cleanup)
  call delete_autogens(islct, jslct, lsort, qall, cleanup)
  call delete_impropers(islct, jslct, lsort, qall, cleanup)
  call delete_cmaps(islct, jslct, lsort, qall, cleanup)
  call cmpric(deleted_mark, lsort)
  if (qdrude) nbdrude = nbond
end subroutine delete_connectivity

subroutine delete_atoms(select_atoms, lsort, cleanup)
  use psf, only: &
       natom, natomt, nbond, nseg, nres, ngrp, nnb, nictot, &
       ibase, igpbs, &
       qdrude, isdrude, ndrude, nbdrude
  use genpsf_m, only: atmini

#if KEY_MMFF==1
  use mmffm, only: mtype
  use ffieldm, only: ffield, mmff
#endif
  
  implicit none

  ! args
  integer, dimension(natom), intent(in) :: select_atoms
  logical, intent(in) :: lsort, cleanup
  
  ! locals
  integer, dimension(NNB) :: LINB
  integer, dimension(NATOMT) :: &
       liblo, &
       MAP, INVMAP, &
       SEGLST, RESLST, GRPLST
  INTEGER :: I, J, II, OFFSET, K

  ! treat all image atoms as if they are also deleted (for IC elements involving image atoms)
  DO I=NATOM+1, NATOMT
     MAP(I) = deleted_mark
  ENDDO

  ! construct MAP and INVMAP
  II=NATOM
  DO I=1,NATOM
     IF (select_atoms(I).EQ.1) THEN
        II=II-1
        MAP(I) = deleted_mark
#if KEY_MMFF==1
        IF(FFIELD.EQ.MMFF) THEN
           MTYPE(I)=0    ! this is necessary for MMFF
           CALL ATMINI(I,I)
        ENDIF
#endif 
     ENDIF
  ENDDO
  IF (NATOM.EQ.II) THEN
     CALL WRNDIE(0,'<DELTIC>', &
          'No atoms selected for deletion. Nothing done.')
     RETURN
  ENDIF

  NATOM=II
  OFFSET=0
  DO I=1,NATOM
     DO WHILE (select_atoms(I+OFFSET).EQ.1)
        OFFSET=OFFSET+1
     ENDDO
     INVMAP(I)=I+OFFSET
  ENDDO

  DO I=1,NATOM
     MAP(INVMAP(I))=I
  ENDDO

  ! fill temporary segment list
  DO I=1,NSEG
     DO J=NICTOT(I)+1,NICTOT(I+1)
        DO K=IBASE(J)+1,IBASE(J+1)
           SEGLST(K)=I
        ENDDO
     ENDDO
  ENDDO

  ! fill temporary residue list
  DO I=1,NRES
     DO J=IBASE(I)+1,IBASE(I+1)
        RESLST(J)=I
     ENDDO
  ENDDO

  ! fill temporary group list
  DO I=1,NGRP
     DO J=IGPBS(I)+1,IGPBS(I+1)
        GRPLST(J)=I
     ENDDO
  ENDDO

  ! now do mapping and compression of PSF,...
  CALL MAPIC(MAP,INVMAP,SEGLST,RESLST,GRPLST,LINB, &
       LIBLO, deleted_mark, .FALSE.)

  if(qdrude)then
     if(natom.eq.0)then
        ndrude = 0
     else
        ndrude = 0
        do i = 1,natom
           if(isdrude(i)) ndrude=ndrude+1
        enddo
     endif
  endif

  if (cleanup) then
     CALL CMPRIC(deleted_mark, LSORT)
     IF(qdrude) nbdrude = nbond
  end if
end subroutine delete_atoms

subroutine delete_bonds(islct, jslct, lsort, qall, cleanup)
  use psf, only: &
       natom, nbond, ib, jb, &
       qdrude, nbdrude
  
  implicit none

  ! args
  integer, dimension(natom), intent(in) :: islct, jslct
  logical, intent(in) :: lsort, qall, cleanup
  
  ! locals
  integer :: i
  logical :: ok, lfirst, lsecond, lall
  
  DO I=1,NBOND
     OK=(IB(I).GT.0 .AND. JB(I).GT.0)
     IF(OK) THEN
        LFIRST=(ISLCT(IB(I)).EQ.1 .AND. JSLCT(JB(I)).EQ.1)
        LSECOND=(JSLCT(IB(I)).EQ.1 .AND. ISLCT(JB(I)).EQ.1)
        LALL=(ISLCT(IB(I)).EQ.1 .AND. ISLCT(JB(I)).EQ.1)
     ENDIF
     IF(.NOT.OK) THEN
        IB(I) = deleted_mark
     ELSE IF(QALL) THEN
        IF(LALL) IB(I) = deleted_mark
     ELSE IF(LFIRST.OR.LSECOND) THEN
        IB(I) = deleted_mark
     ENDIF
  ENDDO

  if (cleanup) then
     CALL CMPRIC(deleted_mark, LSORT)
     IF(qdrude) nbdrude = nbond
  end if
end subroutine delete_bonds

subroutine delete_angles(islct, jslct, lsort, qall, cleanup)
  use psf, only: &
       natom, ntheta, it, jt, kt, &
       qdrude, nbdrude, nbond
  
  implicit none

  ! args
  integer, dimension(natom), intent(in) :: islct, jslct
  logical, intent(in) :: lsort, qall, cleanup
  
  ! locals
  integer :: i
  logical :: ok, lfirst, lsecond, lall

  DO I=1,NTHETA
     OK=(IT(I).GT.0 .AND. JT(I).GT.0 .AND. KT(I).GT.0)
     IF(OK) THEN
        LFIRST=(ISLCT(IT(I)).EQ.1 .OR. ISLCT(JT(I)).EQ.1 .OR. &
                ISLCT(KT(I)).EQ.1)
        LSECOND=(JSLCT(IT(I)).EQ.1 .OR. JSLCT(JT(I)).EQ.1 .OR. &
                 JSLCT(KT(I)).EQ.1)
        LALL=(ISLCT(IT(I)).EQ.1 .AND. ISLCT(JT(I)).EQ.1 .AND. &
              ISLCT(KT(I)).EQ.1)
     ENDIF
     IF(.NOT.OK) THEN
        IT(I) = deleted_mark
     ELSE IF(QALL) THEN
        IF(LALL) IT(I) = deleted_mark
     ELSE IF(LFIRST.AND.LSECOND) THEN
        IT(I) = deleted_mark
     ENDIF
  ENDDO

  if (cleanup) then
     CALL CMPRIC(deleted_mark, LSORT)
     IF(qdrude) nbdrude = nbond
  end if
end subroutine delete_angles

subroutine delete_dihedrals(islct, jslct, lsort, qall, cleanup)
  use psf, only: &
       natom, nphi, ip, jp, kp, lp, &
       qdrude, nbdrude, nbond
  
  implicit none

  ! args
  integer, dimension(natom), intent(in) :: islct, jslct
  logical, intent(in) :: lsort, qall, cleanup
  
  ! locals
  integer :: i
  logical :: ok, lfirst, lsecond, lall

  DO I=1,NPHI
     OK=(IP(I).GT.0 .AND. JP(I).GT.0 .AND. KP(I).GT.0 .AND. &
          LP(I).GT.0)
     IF(OK) THEN
        LFIRST= (ISLCT(IP(I)).EQ.1 .OR. ISLCT(JP(I)).EQ.1 .OR. &
                 ISLCT(KP(I)).EQ.1 .OR. ISLCT(LP(I)).EQ.1)
        LSECOND=(JSLCT(IP(I)).EQ.1 .OR. JSLCT(JP(I)).EQ.1 .OR. &
                 JSLCT(KP(I)).EQ.1 .OR. JSLCT(LP(I)).EQ.1)
        LALL=   (ISLCT(IP(I)).EQ.1 .AND. ISLCT(JP(I)).EQ.1 .AND. &
                 ISLCT(KP(I)).EQ.1 .AND. ISLCT(LP(I)).EQ.1)
     ENDIF
     IF(.NOT.OK) THEN
        IP(I) = deleted_mark
     ELSE IF(QALL) THEN
        IF(LALL) IP(I) = deleted_mark
     ELSE IF(LFIRST.AND.LSECOND) THEN
        IP(I) = deleted_mark
     ENDIF
  ENDDO

  if (cleanup) then
     CALL CMPRIC(deleted_mark, LSORT)
     IF(qdrude) nbdrude = nbond
  end if
end subroutine delete_dihedrals

subroutine delete_autogens(islct, jslct, lsort, qall, cleanup)
  use psf, only: &
       natom, npauto, ipauto, jpauto, kpauto, lpauto, &
       qdrude, nbdrude, nbond
  
  implicit none

  ! args
  integer, dimension(natom), intent(in) :: islct, jslct
  logical, intent(in) :: lsort, qall, cleanup
  
  ! locals
  integer :: i
  logical :: ok, lfirst, lsecond, lall

     DO I=1,NPAUTO
        OK=(IPAUTO(I).GT.0 .AND. JPAUTO(I).GT.0 .AND. KPAUTO(I).GT.0)
        IF(OK) THEN
           LFIRST=(ISLCT(IPAUTO(I)).EQ.1 .OR. ISLCT(JPAUTO(I)).EQ.1 .OR. &
                ISLCT(KPAUTO(I)).EQ.1)
           LSECOND=(JSLCT(IPAUTO(I)).EQ.1 .OR. JSLCT(JPAUTO(I)).EQ.1 .OR. &
                JSLCT(KPAUTO(I)).EQ.1)
           LALL=(ISLCT(IPAUTO(I)).EQ.1 .AND. ISLCT(JPAUTO(I)).EQ.1 .AND. &
                ISLCT(KPAUTO(I)).EQ.1)
           IF(LPAUTO(I).GT.0) THEN
              LFIRST=LFIRST .OR. (ISLCT(LPAUTO(I)).EQ.1)
              LSECOND=LSECOND .OR. (JSLCT(LPAUTO(I)).EQ.1)
              LALL=LALL .AND. (ISLCT(LPAUTO(I)).EQ.1)
           ENDIF
        ENDIF
        IF(.NOT.OK) THEN
           IPAUTO(I)= deleted_mark
        ELSE IF(QALL) THEN
           IF(LALL) IPAUTO(I) = deleted_mark
        ELSE IF(LFIRST.AND.LSECOND) THEN
           IPAUTO(I)= deleted_mark
        ENDIF
     ENDDO

  if (cleanup) then
     CALL CMPRIC(deleted_mark, LSORT)
     IF(qdrude) nbdrude = nbond
  end if
end subroutine delete_autogens

subroutine delete_impropers(islct, jslct, lsort, qall, cleanup)
  use psf, only: &
       natom, nimphi, im, jm, km, lm, &
       qdrude, nbdrude, nbond
  
  implicit none

  ! args
  integer, dimension(natom), intent(in) :: islct, jslct
  logical, intent(in) :: lsort, qall, cleanup
  
  ! locals
  integer :: i
  logical :: ok, lfirst, lsecond, lall

  DO I=1,NIMPHI
     OK=(IM(I).GT.0 .AND. JM(I).GT.0 .AND. KM(I).GT.0 .AND. &
          LM(I).GT.0)
     IF(OK) THEN
        LFIRST=(ISLCT(IM(I)).EQ.1 .OR. ISLCT(JM(I)).EQ.1 .OR. &
                ISLCT(KM(I)).EQ.1 .OR. ISLCT(LM(I)).EQ.1)
        LSECOND=(JSLCT(IM(I)).EQ.1 .OR. JSLCT(JM(I)).EQ.1 .OR. &
                 JSLCT(KM(I)).EQ.1 .OR. JSLCT(LM(I)).EQ.1)
        LALL=(ISLCT(IM(I)).EQ.1 .AND. ISLCT(JM(I)).EQ.1 .AND. &
              ISLCT(KM(I)).EQ.1 .AND. ISLCT(LM(I)).EQ.1)
     ENDIF
     IF(.NOT.OK) THEN
        IM(I) = deleted_mark
     ELSE IF(QALL) THEN
        IF(LALL) IM(I) = deleted_mark
     ELSE IF(LFIRST.AND.LSECOND) THEN
        IM(I) = deleted_mark
     ENDIF
  ENDDO

  if (cleanup) then
     CALL CMPRIC(deleted_mark, LSORT)
     IF(qdrude) nbdrude = nbond
  end if
end subroutine delete_impropers

subroutine delete_cmaps(islct, jslct, lsort, qall, cleanup)

  use psf, only: &
       natom, &
#if KEY_CMAP == 1
       ncrterm, &
       i1ct, j1ct, k1ct, l1ct, &
       i2ct, j2ct, k2ct, l2ct, &
#endif /* KEY_CMAP */
       qdrude, nbdrude, nbond

  implicit none

  ! args
  integer, dimension(natom), intent(in) :: islct, jslct
  logical, intent(in) :: lsort, qall, cleanup
  
  ! locals
  integer :: i
  logical :: ok, lfirst, lsecond, lall

#if KEY_CMAP == 1
  DO I=1,NCRTERM
     OK= (I1CT(I).GT.0 .AND. J1CT(I).GT.0 .AND. &
          K1CT(I).GT.0 .AND. L1CT(I).GT.0 .AND. &
          I2CT(I).GT.0 .AND. J2CT(I).GT.0 .AND. &
          K2CT(I).GT.0 .AND. L2CT(I).GT.0)
     IF(OK) THEN
        LFIRST= (ISLCT(I1CT(I)).EQ.1 .OR. &
                 ISLCT(J1CT(I)).EQ.1 .OR. &
                 ISLCT(K1CT(I)).EQ.1 .OR. &
                 ISLCT(L1CT(I)).EQ.1 .OR. &
                 ISLCT(I2CT(I)).EQ.1 .OR. &
                 ISLCT(J2CT(I)).EQ.1 .OR. &
                 ISLCT(K2CT(I)).EQ.1 .OR. &
                 ISLCT(L2CT(I)).EQ.1)
        LSECOND=(JSLCT(I1CT(I)).EQ.1 .OR. &
                 JSLCT(J1CT(I)).EQ.1 .OR. &
                 JSLCT(K1CT(I)).EQ.1 .OR. &
                 JSLCT(L1CT(I)).EQ.1 .OR. &
                 JSLCT(I2CT(I)).EQ.1 .OR. &
                 JSLCT(J2CT(I)).EQ.1 .OR. &
                 JSLCT(K2CT(I)).EQ.1 .OR. &
                 JSLCT(L2CT(I)).EQ.1)
        LALL=   (ISLCT(I1CT(I)).EQ.1 .AND. &
                 ISLCT(J1CT(I)).EQ.1 .AND. &
                 ISLCT(K1CT(I)).EQ.1 .AND. &
                 ISLCT(L1CT(I)).EQ.1 .AND. &
                 ISLCT(I2CT(I)).EQ.1 .AND. &
                 ISLCT(J2CT(I)).EQ.1 .AND. &
                 ISLCT(K2CT(I)).EQ.1 .AND. &
                 ISLCT(L2CT(I)).EQ.1)
     ENDIF
     IF(.NOT.OK) THEN
        I1CT(I)=DELETED_MARK
        I2CT(I)=DELETED_MARK
     ELSE IF(QALL) THEN
        IF(LALL) THEN
          I1CT(I) = deleted_mark
          I2CT(I)=DELETED_MARK
        ENDIF
     ELSE IF(LFIRST.AND.LSECOND) THEN
        I1CT(I)=DELETED_MARK
        I2CT(I)=DELETED_MARK
     ENDIF
  ENDDO

  if (cleanup) then
     CALL CMPRIC(deleted_mark, LSORT)
     IF(qdrude) nbdrude = nbond
  end if
#endif /* KEY_CMAP */
end subroutine delete_cmaps

SUBROUTINE MAPIC(MAP,INVMAP,SEGLST,RESLST,GRPLST,LINB, &
     LIBLO,MARK,BYPASS)
  !-----------------------------------------------------------------------
  !  This routine maps PSF, coordinates, constraints and IC's according to
  !  a MAP and its inverse INV_MAP. GRP_LST contains a group number for
  !  each atom and is used to redefine the group boundaries. See PATIC2
  !  for use of this routine. If BYPASS only the groups are redefined.
  !
  !
  !    MAP(NATOM)    - Forward map, for each atom, what does it become?
  !    INVMAP(NATOM) - Inverse map, for each atom, where did it come from?
  !    SEGLST        -
  !    RESLST        -
  !    GRPLST        -
  !    LINB          -
  !    LIBLO         -
  !    MARK          - The value to mark an atom for deletion
  !    BYPASS        - Logical flag to skip atom remapping
  !
  !
  !     NOTE: THIS ROUTINE MAY BE MODIFIED IF THE PSF, COORDINATES,
  !     CONSTRAINTS OR IC COMMON BLOCKS ARE MODIFIED.
  !     AFTER CALLING THIS ROUTINE A CALL TO CMPRIC IS NECESSARY TO
  !     DELETE MARKED ATOMS IN ALL LISTS.
  !
  !     23-JAN-83 AB
  !

#if KEY_CHEQ==1
  use cheq,only: ech,eha,qcgrp,molbl,molsrt,allocate_cheq  
#endif

  use dimens_fcm
  use psf
  use aniso_fcm
  use coord
  use coordc
  use cnst_fcm
  use hbondm
  use stream
  use lonepr
  use noem
#if KEY_REPLICA==1
  use replica_mod      
#endif
  use mmffm
  use ffieldm
  use memory
  use intcor_module,only:remapic
  use chutil,only:getres
#ifdef KEY_RESIZE
  use deriv
  use resize
#endif  
  !
  integer,allocatable,dimension(:) :: WORK
  integer,allocatable,dimension(:,:) :: WORK2D
  real(chm_real),allocatable,dimension(:) :: RWORK
  logical,allocatable,dimension(:) :: LWORK
  INTEGER :: MAP(:), INVMAP(:), SEGLST(:)
  INTEGER :: RESLST(:), GRPLST(:)
  INTEGER :: LINB(:), LIBLO(:)
  INTEGER   MARK
  INTEGER   IX, NANISOLD
  LOGICAL   BYPASS, OK
  !
  INTEGER   NDEL
  character(len=8),allocatable,dimension(:) :: cwork
  real(chm_real)    QTOT
  INTEGER   GROUP, I, IR, II, J, JJ, IGRP, RESIDU, SEGMEN
  INTEGER   I2, JS
#ifdef KEY_RESIZE
  INTEGER nn0,ng0,nr0,ns0,na0
  ! Keep old numbers
  nn0=NNB; ng0=NGRP; nr0=NRES; ns0=NSEG; na0=NATOM
#endif  
  !
  call chmalloc(SRCFILE,'MAPIC','WORK',NATOM,intg=WORK)
  call chmalloc(SRCFILE,'MAPIC','cWORK',NATOM,ch8=cWORK)
  call chmalloc(SRCFILE,'MAPIC','RWORK',NATOM,crl=RWORK)
  call chmalloc(SRCFILE,'MAPIC','LWORK',NATOM,log=LWORK)
  IF(.NOT.BYPASS) THEN
     !
     IF(PRNLEV.GE.2) WRITE(OUTU,1500)
1500 FORMAT(/' Message from MAPIC: Atom numbers are changed.')
     CALL AINDX4(INVMAP,IAC,NATOM,WORK)
     CALL AINDEX(INVMAP,AMASS,NATOM,RWORK)
#if KEY_MMFF==1
     if(ffield == mmff) CALL AINDX4(INVMAP,AtNum,NATOM,WORK) 
#endif
     ! SAPATEL
#if KEY_CHEQ==1
     CALL AINDEX(INVMAP,ECH,NATOM,RWORK)
     CALL AINDEX(INVMAP,EHA,NATOM,RWORK)
#endif 
     ! SAPATEL
     CALL AINDEX(INVMAP,CG,NATOM,RWORK)
     CALL AINDXC(INVMAP,ATYPE,NATOM,CWORK)
     CALL AINDX4(INVMAP,IMOVE,NATOM,WORK)
     CALL AINDEX(INVMAP,ALPHADP,NATOM,RWORK)
     CALL AINDEX(INVMAP,THOLEI,NATOM,RWORK)
     CALL AINDXL(INVMAP,ISDRUDE,NATOM,LWORK)
     CALL AINDX4(INVMAP,ICAAUTO,NATOM,WORK)
     !
     CALL AINDEX(INVMAP,X,NATOM,RWORK)
     CALL AINDEX(INVMAP,Y,NATOM,RWORK)
     CALL AINDEX(INVMAP,Z,NATOM,RWORK)
     CALL AINDEX(INVMAP,WMAIN,NATOM,RWORK)
     CALL AINDEX(INVMAP,XCOMP,NATOM,RWORK)
     CALL AINDEX(INVMAP,YCOMP,NATOM,RWORK)
     CALL AINDEX(INVMAP,ZCOMP,NATOM,RWORK)
     CALL AINDEX(INVMAP,WCOMP,NATOM,RWORK)
#if KEY_WCA==1
     CALL AINDEX(INVMAP,WCA,NATOM,RWORK)
#endif
     CALL AINDEX(INVMAP,RSCLF,NATOM,RWORK)

     if (qcnstr .and. cnst_is_allocated) then
        if (size(ihset) .lt. natom) then
           call wrndie(-5, '<MAPIC>', &
                'Harmonic restraint arrays not correct size.')
        end if
        call aindex(invmap, kcnstr, natom, rwork)
        call aindx4(invmap, ihset, natom, work)
        call aindex(invmap, refx, natom, rwork)
        call aindex(invmap, refy, natom, rwork)
        call aindex(invmap, refz, natom, rwork)
        call aindex(invmap, fbeta, natom, rwork)
     else if (qcnstr) then
        call wrndie(-5, '<MAPIC>', &
             'Harmonic restraint arrays not allocated.')
     end if

#if KEY_REPLICA==1
     !# <caves>-Aug-4-1993 (Leo Caves) Remap replica atom flags and weights
     IF (qRep) THEN
        CALL AINDEX(INVMAP,repWt,NATOM,RWORK)
        CALL AINDX4(INVMAP,repNoA,NATOM,WORK)
     ENDIF ! qRep
#endif /*  REPLICA*/
     CALL AVALUE(MAP,ICS,NCSPHI,MARK)
     CALL AVALUE(MAP,JCS,NCSPHI,MARK)
     CALL AVALUE(MAP,KCS,NCSPHI,MARK)
     CALL AVALUE(MAP,LCS,NCSPHI,MARK)
     !
     CALL AVALUE(MAP,IB,NBOND,MARK)
     CALL AVALUE(MAP,JB,NBOND,MARK)
     !
     CALL AVALUE(MAP,IT,NTHETA,MARK)
     CALL AVALUE(MAP,JT,NTHETA,MARK)
     CALL AVALUE(MAP,KT,NTHETA,MARK)
     !
     CALL AVALUE(MAP,IP,NPHI,MARK)
     CALL AVALUE(MAP,JP,NPHI,MARK)
     CALL AVALUE(MAP,KP,NPHI,MARK)
     CALL AVALUE(MAP,LP,NPHI,MARK)
     !
     CALL AVALUE(MAP,IPAUTO,NPAUTO,MARK)
     CALL AVALUE(MAP,JPAUTO,NPAUTO,MARK)
     CALL AVALUE(MAP,KPAUTO,NPAUTO,MARK)
     CALL AVALUE(MAP,LPAUTO,NPAUTO,MARK)
     !
     CALL AVALUE(MAP,IM,NIMPHI,MARK)
     CALL AVALUE(MAP,JM,NIMPHI,MARK)
     CALL AVALUE(MAP,KM,NIMPHI,MARK)
     CALL AVALUE(MAP,LM,NIMPHI,MARK)
     
#if KEY_CMAP==1
     CALL AVALUE(MAP,I1CT,NCRTERM,MARK)
     CALL AVALUE(MAP,J1CT,NCRTERM,MARK)
     CALL AVALUE(MAP,K1CT,NCRTERM,MARK)
     CALL AVALUE(MAP,L1CT,NCRTERM,MARK)
     CALL AVALUE(MAP,I2CT,NCRTERM,MARK)
     CALL AVALUE(MAP,J2CT,NCRTERM,MARK)
     CALL AVALUE(MAP,K2CT,NCRTERM,MARK)
     CALL AVALUE(MAP,L2CT,NCRTERM,MARK)
#endif 
     !
     CALL AVALUE(MAP,IHD1,NDON,MARK)
     CALL AVALUE(MAP,IDON,NDON,MARK)
     !
     CALL AVALUE(MAP,IACC,NACC,MARK)
     CALL AVALUE(MAP,IAC1,NACC,MARK)
     !
#if KEY_NOMISC==0
     CALL AVALUE(MAP,NOELIS,NOENM2,MARK)
#endif 
     !
#if KEY_LONEPAIR==1
     CALL AVALUE(MAP,LPHOST,NUMLPH,MARK)
     !
     ! Do we need to remove any deleted lonepairs?
     OK=.TRUE.
     DO I=1,NUMLPH
        IF(LPHOST(I).EQ.MARK) OK=.FALSE.
     ENDDO
     ! If not OK, then we need to remove some lonepairs
     IF(.NOT.OK) CALL LONEPRD(MARK)
#endif 
         CALL AVALUE(MAP,LSTANI1,NANISO,MARK)
         CALL AVALUE(MAP,LSTANI2,NANISO,MARK)
         CALL AVALUE(MAP,LSTANI3,NANISO,MARK)
         CALL AVALUE(MAP,LSTANI4,NANISO,MARK)

         NANISOLD=NANISO
         NANISO=0
         DO I=1,NANISOLD
           IF((LSTANI1(I).EQ.MARK).OR.(LSTANI2(I).EQ.MARK) &
           .OR.(LSTANI3(I).EQ.MARK).OR.(LSTANI4(I).EQ.MARK))THEN
              NANISO=NANISO
           ELSE
              NANISO=NANISO+1
              LSTANI1(NANISO)=LSTANI1(I)
              LSTANI2(NANISO)=LSTANI2(I)
              LSTANI3(NANISO)=LSTANI3(I)
              LSTANI4(NANISO)=LSTANI4(I)
              K11(NANISO)=K11(I)
              K22(NANISO)=K22(I)
              K33(NANISO)=K33(I)
           ENDIF
         ENDDO
         IF(NANISOLD.GT.NANISO .and. prnlev.ge.2)THEN
            write(outu,*) NANISOLD-NANISO,' anisotropic terms deleted'
         ENDIF

     ! Remove any worthless dihedral constraint table entries
     II=0
     DO I=1,NCSPHI
        IF(ICS(I).NE.MARK .AND. JCS(I).NE.MARK .AND. &
             KCS(I).NE.MARK .AND. LCS(I).NE.MARK) THEN
           II=II+1
           ICS(II)=ICS(I)
           JCS(II)=JCS(I)
           KCS(II)=KCS(I)
           LCS(II)=LCS(I)
        ENDIF
     ENDDO
     NDEL=NCSPHI-II
     NCSPHI=II
     IF(NDEL.GT.0 .AND. PRNLEV.GE.2) WRITE(OUTU,22) &
          NDEL,'dihedral constraints'
22   FORMAT(' DELTIC:',I10,1X,A,' deleted')
     !
#if KEY_NOMISC==0
     ! Remove any worthless NOE constraint table entries
     NDEL=0
     DO I=1,NOENUM
        II=NOEIPT(I)-1
        DO J=1,NOEINM(I)
           IF(NOELIS(II+J).EQ.MARK) THEN
              NOEINM(I)=0
              NOEJNM(I)=0
              NDEL=NDEL+1
              GOTO 125
           ENDIF
        ENDDO
        II=NOEJPT(I)-1
        DO J=1,NOEJNM(I)
           IF(NOELIS(II+J).EQ.MARK) THEN
              NOEINM(I)=0
              NOEJNM(I)=0
              NDEL=NDEL+1
              GOTO 125
           ENDIF
        ENDDO
125     CONTINUE
     ENDDO
     IF(NDEL.GT.0 .AND. PRNLEV.GE.2) WRITE(OUTU,22) &
          NDEL,'NOE restraints'
#endif 
     !
     !  Remap all internal coordinate tables.
     CALL REMAPIC(MAP,MARK)
     !
     CALL AINDX4(INVMAP,RESLST,NATOM,WORK)
     CALL AINDX4(INVMAP,SEGLST,NATOM,WORK)
     CALL AINDX4(INVMAP,GRPLST,NATOM,WORK)
     !
     !
     ! re-define INB, IBLO explicit non-bond-exclusion list.
     !
     CALL AVALUE(MAP,INB,NNB,MARK)
     !
     NNB=0
     DO I=1,NATOM
        IF(INVMAP(I).EQ.1) THEN
           JS=1
        ELSE
           JS=IBLO(INVMAP(I)-1)+1
        ENDIF
        DO J=JS,IBLO(INVMAP(I))
           IF (INB(J).NE.MARK) THEN
              NNB=NNB+1
              LINB(NNB)=INB(J)
           ENDIF
        ENDDO
        LIBLO(I)=NNB
     ENDDO
     !
     DO I=1,NATOM
        IBLO(I)=LIBLO(I)
     ENDDO
     DO I=1,NNB
        INB(I)=LINB(I)
     ENDDO
     !
     !
     !     Redefine residue pointers IBASE as well as RES and RESID:
     !
     !
     RESIDU=-1
     II=NRES
     NRES=0
     DO I=1,NATOM
        IF(RESIDU.NE.RESLST(I)) THEN
           RESIDU=RESLST(I)
           NRES=NRES+1
           IBASE(NRES)=I-1
           INVMAP(NRES)=RESLST(I)
        ENDIF
     ENDDO
     IBASE(NRES+1)=NATOM
     !
     CALL AINDXC(INVMAP,RES,NRES,CWORK)
     CALL AINDXC(INVMAP,RESID,NRES,CWORK)
     !
     IF(NRES.NE.II .AND. PRNLEV.GE.2) WRITE(OUTU,1070) (II-NRES)
1070 FORMAT(/' Message from MAPIC: ',I10,' residues deleted.')
     !
     ! Redefine segment pointers NICTOT(*) as well as SEGID:
     !
     !
     SEGMEN=-1
     II=NSEG
     NSEG=0
     DO I=1,NATOM
        IF (SEGMEN.NE.SEGLST(I)) THEN
           SEGMEN=SEGLST(I)
           NSEG=NSEG+1
           I2=I
           NICTOT(NSEG)=GETRES(I2,IBASE,NRES)-1
           INVMAP(NSEG)=SEGLST(I)
        ENDIF
     ENDDO
     NICTOT(NSEG+1)=NRES
     !
     CALL AINDXC(INVMAP,SEGID,NSEG,CWORK)
     !
     IF (NSEG.NE.II .AND. PRNLEV.GE.2) WRITE(OUTU,1080) (II-NSEG)
1080 FORMAT(/' Message from MAPIC: ',I10,' segments deleted.')
  ENDIF
  !
  ! now re-define groups:
  !
  GROUP=-1
  NGRP=0
  DO I=1,NATOM
     IF(GROUP.NE.GRPLST(I)) THEN
        GROUP=GRPLST(I)
#ifndef KEY_RESIZE
        IF(NGRP.GE.MAXGRP) THEN
           CALL WRNDIE(-4,'<MAPIC>','Max. numb. of groups MAXGRP exceeded')
        ELSE
#endif           
           NGRP=NGRP+1
#ifdef KEY_RESIZE
           if (ngrp .gt. ng0) then
              ng0=ngrp+drsz0
              call resize_psf('modpsf.F90','MAPIC','NGRP',ng0, .true.)
           endif
#endif           
           IGPBS(NGRP)=I-1
           IMOVEG(NGRP)=0
        ENDIF
#ifndef KEY_RESIZE
     ENDIF
#endif
  ENDDO
  IGPBS(NGRP+1)=NATOM
  !
  ! Find group types
  !
  NST2=0
  IR=1
  DO IGRP=1,NGRP
     II=IGPBS(IGRP)+1
     JJ=IGPBS(IGRP+1)
     !
     DO WHILE(IBASE(IR+1).LT.II)
        IR=IR+1
     ENDDO
     I=1
     DO WHILE (IMOVE(I).GT.0 .AND. I.LT.JJ)
        I=I+1
     ENDDO
     IF(IMOVE(I).GT.0) THEN
        IMOVEG(IGRP)=1
     ELSE
        IMOVEG(IGRP)=0
     ENDIF
     !
     ! Test for ST2
     !
     IF(RES(IR).NE.'ST2 ') THEN
        !
#if KEY_REPLICA==1
        !# <caves>-Aug-4-1993 (Leo Caves) remap replica group membership
        IF (qRep) repNoG(iGrp) = repNoA(ii)
#endif /*  REPLICA*/
        !
        IGPTYP(IGRP)=0
        QTOT=0.0
        DO I=II,JJ
           QTOT=QTOT+CG(I)
           IF(CG(I).NE.0.0) IGPTYP(IGRP)=1
        ENDDO
        IF(ABS(QTOT).GT.0.0001) IGPTYP(IGRP)=2
     ELSE
        !
        !     Group is of ST2 type
        !
#if KEY_NOST2==0
        NST2=NST2+1
        IGPTYP(IGRP)=3
        IF((JJ-II).NE.4) &
             CALL WRNDIE(0,'<MAPIC>',' ST2 group must have 5 atoms')
        IMOVE(JJ-1)=-1
        IMOVE(JJ)=-1
#else /**/
        CALL WRNDIE(-1,'<MAPIC>','ST2 code is not compiled.')
#endif 
     ENDIF
  ENDDO
  !
  !     reset hbond list:
  !
  NHB=0
  !
  call chmdealloc(SRCFILE,'MAPIC','WORK',NATOM,intg=WORK)
  call chmdealloc(SRCFILE,'MAPIC','cWORK',NATOM,ch8=cWORK)
  call chmdealloc(SRCFILE,'MAPIC','RWORK',NATOM,crl=RWORK)
  call chmdealloc(SRCFILE,'MAPIC','LWORK',NATOM,log=LWORK)

  ! SAPATEL
#if KEY_CHEQ==1
#if KEY_REPLICA==1
  IF(.NOT.QREP) THEN      
#endif
     ! sort for molecular label
     if(allocated(molbl)) then
        ! psf changed, check whether arrays are still right size
        call allocate_cheq(natom, ngrp)
        CALL MOLSRT(NATOM,IB,JB,NBOND,QCGRP,NGRP,IGPBS)
     endif
#if KEY_REPLICA==1
  ENDIF                   
#endif
#endif 
  ! SAPATEL
#ifdef KEY_RESIZE
  ! resize after deletion done
!  if (nn0 .ne. NNB) & ! resizing done via NATOM ! hwm: check
  if (ng0 .ne. NGRP) &
       call resize_psf('modpsf.F90','MAPIC','NGRP',NGRP, .true.)
  if (nr0 .ne. NRES) &
       call resize_psf('modpsf.F90','MAPIC','NRES',nres, .true.)
  if (ns0 .ne. NSEG) &
       call resize_psf('modpsf.F90','MAPIC','NSEG',nseg, .true.)
  ! NATOM changed when MAPIC is called; resize anyway
  call resize_psf('modpsf.F90','MAPIC','NATOM',natom, .true.)
  call resize_coord('modpsf.F90','MAPIC',natom, .true.)
  call resize_coordc('modpsf.F90','MAPIC',natom, .true.)
  call resize_deriv('modpsf.F90','MAPIC',natom, .true.)
  !endif
#endif    
  RETURN
END SUBROUTINE MAPIC

SUBROUTINE CMPRIC(MARK,LSORT)
  !-----------------------------------------------------------------------
  !     This routine deletes marked bonds, angles, ..., IC's and
  !     compresses PSF and IC listings. Optional a sorting is performed.
  !
  !     23-JAN-83, Axel Brunger
  !
  use dimens_fcm
  use exfunc
  use psf
  use stream
  use mmffm
  use ffieldm
  use chutil,only:atomid
#ifdef KEY_RESIZE
  use resize
#endif  

  INTEGER   MARK
  LOGICAL   LSORT
  !
  !
  EXTERNAL  EXCH5
#if KEY_CMAP==1
  EXTERNAL EXCH8
#endif 
  INTEGER   I, II, NL
  LOGICAL   CONDIT
  INTEGER NDEL
  !C
  character(len=8) SIDDN,RIDDN,RESDN,ATDN
#ifdef KEY_RESIZE
  INTEGER nb0, nt0, np0, ni0, nc0, nd0, na0
  ! keep old numbers
  nb0=NBOND;  nt0=NTHETA; np0=NPHI; ni0=NIMPHI
  nc0=NCRTERM; nd0=NDON; na0=NACC
#endif  
  !
  !     compress bond lists,...
  !
  II=0
  DO I=1,NBOND
     CONDIT=(IB(I).EQ.MARK.OR.JB(I).EQ.MARK)
     IF(.NOT.CONDIT) THEN
        II=II+1
        IB(II)=IB(I)
        JB(II)=JB(I)
        ICBAUTO(II)=ICBAUTO(I)
#if KEY_MMFF==1
        if(ffield == mmff)  BondType(II)=BondType(I) 
#endif
     ENDIF
  ENDDO
  NDEL=NBOND-II
  NBOND=II
  IF(NDEL.GT.0 .AND. PRNLEV.GE.2) WRITE(OUTU,22) NDEL,'bonds'
22 FORMAT(' DELTIC:',I10,1X,A,' deleted')
  !
  II=0
  DO I=1,NTHETA
     CONDIT=(IT(I).EQ.MARK.OR.JT(I).EQ.MARK.OR.KT(I).EQ.MARK)
     IF(.NOT. CONDIT) THEN
        II=II+1
        IT(II)=IT(I)
        JT(II)=JT(I)
        KT(II)=KT(I)
     ENDIF
  ENDDO
  NDEL=NTHETA-II
  NTHETA=II
  IF(NDEL.GT.0 .AND. PRNLEV.GE.2) WRITE(OUTU,22) NDEL,'angles'
  !
  II=0
  DO I=1,NPHI
     CONDIT=(IP(I).EQ.MARK.OR.JP(I).EQ.MARK.OR.KP(I).EQ.MARK &
          .OR.LP(I).EQ.MARK)
     IF(.NOT.CONDIT) THEN
        II=II+1
        IP(II)=IP(I)
        JP(II)=JP(I)
        KP(II)=KP(I)
        LP(II)=LP(I)
     ENDIF
  ENDDO
  NDEL=NPHI-II
  NPHI=II
  IF(NDEL.GT.0 .AND. PRNLEV.GE.2) WRITE(OUTU,22) NDEL,'dihedrals'
  !
  II=0
  DO I=1,NPAUTO
     CONDIT=(IPAUTO(I).EQ.MARK.OR.JPAUTO(I).EQ.MARK.OR. &
             KPAUTO(I).EQ.MARK.OR.LPAUTO(I).EQ.MARK)
     IF(.NOT.CONDIT) THEN
        II=II+1
        IPAUTO(II)=IPAUTO(I)
        JPAUTO(II)=JPAUTO(I)
        KPAUTO(II)=KPAUTO(I)
        LPAUTO(II)=LPAUTO(I)
        ICPAUTO(II)=ICPAUTO(I)
     ENDIF
  ENDDO
  NDEL=NPAUTO-II
  NPAUTO=II
  IF(NDEL.GT.0 .AND. PRNLEV.GE.2) WRITE(OUTU,22) NDEL,'autogen elements'
  !
  II=0
  DO I=1,NIMPHI
     CONDIT=(IM(I).EQ.MARK.OR.JM(I).EQ.MARK.OR.KM(I).EQ.MARK &
          .OR.LM(I).EQ.MARK)
     IF(.NOT.CONDIT) THEN
        II=II+1
        IM(II)=IM(I)
        JM(II)=JM(I)
        KM(II)=KM(I)
        LM(II)=LM(I)
     ENDIF
  ENDDO
  NDEL=NIMPHI-II
  NIMPHI=II
  IF(NDEL.GT.0 .AND. PRNLEV.GE.2) WRITE(OUTU,22) NDEL, &
       'improper dihedrals'

#if KEY_CMAP==1
  II=0
  DO I=1,NCRTERM
     CONDIT=(I1CT(I).EQ.MARK.OR.J1CT(I).EQ.MARK.OR. &
          K1CT(I).EQ.MARK.OR.L1CT(I).EQ.MARK.OR. &
          I2CT(I).EQ.MARK.OR.J2CT(I).EQ.MARK.OR. &
          K2CT(I).EQ.MARK.OR.L2CT(I).EQ.MARK)
     IF(.NOT.CONDIT) THEN
        II=II+1
        I1CT(II)=I1CT(I)
        J1CT(II)=J1CT(I)
        K1CT(II)=K1CT(I)
        L1CT(II)=L1CT(I)

        I2CT(II)=I2CT(I)
        J2CT(II)=J2CT(I)
        K2CT(II)=K2CT(I)
        L2CT(II)=L2CT(I)
     ENDIF
  ENDDO
  NDEL=NCRTERM-II
  NCRTERM=II
  IF(NDEL.GT.0 .AND. PRNLEV.GE.2) WRITE(OUTU,22) NDEL, &
       'crossterm maps'
#endif 

  !
  CALL SORT(NDON,EXCH5,ORDER5,IDON,IHD1,0,0,0,0,0,2)
  II=0
  DO I=1,NDON
     CONDIT=(IDON(I).EQ.MARK.OR.IHD1(I).EQ.MARK)
     !
     IF(II.GT.0 .AND. .NOT.CONDIT) THEN
        IF(IDON(I).EQ.IDON(II).AND.IHD1(I).EQ.IHD1(II)) THEN
           CONDIT=.TRUE.
           !C
           NL=IDON(I)
           CALL ATOMID(NL,SIDDN,RIDDN,RESDN,ATDN)
           IF(WRNLEV.GE.2) WRITE(OUTU,'(a,4(1x,a),a)') &
                ' DUPLICATE DONOR FOUND FOR ', &
                SIDDN(1:idleng),RIDDN(1:idleng), &
                RESDN(1:idleng),ATDN(1:idleng)
           IF (IHD1(I).NE.0) THEN
              NL=IHD1(I)
              CALL ATOMID(NL,SIDDN,RIDDN,RESDN,ATDN)
              IF(WRNLEV.GE.2) WRITE(OUTU,'(a,4(1x,a),a)') &
                   ' WITH DONOR HYDROGEN ', &
                   SIDDN(1:idleng),RIDDN(1:idleng), &
                   RESDN(1:idleng),ATDN(1:idleng)
           ENDIF
           IF(WRNLEV.GE.2) WRITE(OUTU,'(a)') &
                ' DUPLICATE ENTRY REMOVED.'
           !
        ENDIF
     ENDIF
     !
     IF(.NOT.CONDIT) THEN
        II=II+1
        IDON(II)=IDON(I)
        IHD1(II)=IHD1(I)
     ENDIF
  ENDDO
  NDEL=NDON-II
  NDON=II
  IF(NDEL.GT.0 .AND. PRNLEV.GE.2) WRITE(OUTU,22) NDEL,'donors'
  !
  CALL SORT(NACC,EXCH5,ORDER5,IACC,IAC1,0,0,0,0,0,2)
  II=0
  DO I=1,NACC
     CONDIT=(IACC(I).EQ.MARK.OR.IAC1(I).EQ.MARK)
     !
     IF(II.GT.0 .AND. .NOT.CONDIT) THEN
        IF(IACC(I).EQ.IACC(II)) THEN
           CONDIT=.TRUE.
           !C
           NL=IACC(I)
           CALL ATOMID(NL,SIDDN,RIDDN,RESDN,ATDN)
           IF(WRNLEV.GE.2) WRITE(OUTU,'(a,4(1x,a),a)') &
                ' DUPLICATE ACCEPTOR FOUND FOR ', &
                SIDDN(1:idleng),RIDDN(1:idleng), &
                RESDN(1:idleng),ATDN(1:idleng)
           IF (IAC1(I).NE.0) THEN
              NL=IAC1(I)
              CALL ATOMID(NL,SIDDN,RIDDN,RESDN,ATDN)
              IF(WRNLEV.GE.2) WRITE(OUTU,'(a,4(1x,a),a)') &
                   ' ACCEPTOR ANTECEDENT ', &
                   SIDDN(1:idleng),RIDDN(1:idleng), &
                   RESDN(1:idleng),ATDN(1:idleng), &
                   ' REMOVED.'
           ENDIF
           IF (IAC1(II).NE.0) THEN
              NL=IAC1(II)
              CALL ATOMID(NL,SIDDN,RIDDN,RESDN,ATDN)
              IF(WRNLEV.GE.2) WRITE(OUTU,'(a,4(1x,a),a)') &
                   ' ACCEPTOR ANTECEDENT ', &
                   SIDDN(1:idleng),RIDDN(1:idleng), &
                   RESDN(1:idleng),ATDN(1:idleng), &
                   ' REMOVED.'
           ENDIF
           IF(WRNLEV.GE.2) WRITE(OUTU,'(a)') &
                ' DUPLICATE ENTRY REMOVED.'
           !C
           IAC1(II)=0
        ENDIF
     ENDIF
     !
     IF(.NOT.CONDIT) THEN
        II=II+1
        IACC(II)=IACC(I)
        IAC1(II)=IAC1(I)
     ENDIF
  ENDDO
  NDEL=NACC-II
  NACC=II
  IF(NDEL.GT.0 .AND. PRNLEV.GE.2) WRITE(OUTU,22) NDEL,'acceptors'
  !
  ! finally sort all lists if LSORT is true
  !
  IF (LSORT) THEN
     CALL SORT(NBOND,EXCH5,ORDER5,IB,JB,ICBAUTO,0,0,0,0,3)
     CALL SORT(NTHETA,EXCH5,ORDER5,IT,JT,KT,0,0,0,0,3)
     CALL SORT(NPHI,EXCH5,ORDER5,IP,JP,KP,LP,0,0,0,4)
     CALL SORT(NPAUTO,EXCH5,ORDER5,IPAUTO,JPAUTO,KPAUTO,LPAUTO,ICPAUTO,0,0,5)
     CALL SORT(NIMPHI,EXCH5,ORDER5,IM,JM,KM,LM,0,0,0,4)
#if KEY_CMAP==1
     CALL SORT(NCRTERM,EXCH8,ORDER8, &
          I1CT,J1CT,K1CT,L1CT,I2CT,J2CT,K2CT,L2CT)
#endif 
     CALL SORT(NDON,EXCH5,ORDER5,IDON,IHD1,0,0,0,0,0,2)
     CALL SORT(NACC,EXCH5,ORDER5,IACC,IAC1,0,0,0,0,0,2)
  ENDIF
#ifdef KEY_RESIZE
  ! resize after deletion
  if (nb0 .ne. NBOND) &
       call resize_psf('modpsf.F90','CMPRIC','NBOND',nbond, .true.)
  if (nt0 .ne. NTHETA) &
       call resize_psf('modpsf.F90','CMPRIC','NTHETA',NTHETA, .true.)  
  if (np0 .ne. NPHI) &
       call resize_psf('modpsf.F90','CMPRIC','NPHI',NPHI, .true.)
  if (ni0 .ne. NIMPHI) &
       call resize_psf('modpsf.F90','CMPRIC','NIMPHI',NIMPHI, .true.)
  if (nc0 .ne. NCRTERM) &
       call resize_psf('modpsf.F90','CMPRIC','NCRTERM',NCRTERM, .true.)  
  if (nd0 .ne. NDON) &
       call resize_psf('modpsf.F90','CMPRIC','NDON',NDON, .true.)  
  if (na0 .ne. NACC) &
       call resize_psf('modpsf.F90','CMPRIC','NACC',NACC, .true.)
#endif  
  !
  RETURN
END SUBROUTINE CMPRIC

SUBROUTINE ADDSRCHAT(SID,PDEF,NXGRID,NYGRID,NZGRID, &
     XMAT,YMAT,ZMAT,MAT)
  !
  ! This routine adds dummy atoms based on a grid of selected
  ! points (called from the COOR SEARch command).
  !
  !     By Bernard R. Brooks  1998
  !
  use cnst_fcm, only: cnst_is_allocated, allocate_cnst
  use dimens_fcm
  use exfunc
  use number
  use psf
  use rtf,only: atct, natct, armass, rtfautoc
  use coord
  use stream
#ifdef KEY_RESIZE
  use resize
#endif

  character(len=*) SID,PDEF
  INTEGER     NXGRID,NYGRID,NZGRID
  real(chm_real)      XMAT(NXGRID),YMAT(NYGRID),ZMAT(NZGRID)
  INTEGER     MAT(*)
  !
  INTEGER I,J,K,IPT,NADD,TYPECD
  character(len=8) TYPENM
#ifdef KEY_RESIZE
  integer na0,ng0
#endif  
  !
  TYPENM=PDEF
  TYPECD=SRCHWS(ATCT,NATCT,TYPENM)
  IF (TYPECD.EQ.0) THEN
     CALL WRNDIE(-2,'<ADDSRCHAT>','Bad atom type code specified')
     RETURN
  ENDIF
  !
  IPT=0
  NADD=0
#ifdef KEY_RESIZE  
  na0=natom ! temporary counter
  ng0=ngrp
#endif  
  DO I=1,NXGRID
     DO J=1,NYGRID
        DO K=1,NZGRID
           IPT=IPT+1
           IF(MAT(IPT).GE.1) NADD=NADD+1
        ENDDO
     ENDDO
  ENDDO
  !
  IF(NATOM+NADD.GT.MAXA .OR. NGRP+NADD.GT.MAXGRP) THEN
     CALL WRNDIE(-2,'<ADDSRCHAT>','Too many grid points to add as dummy atoms')
     RETURN
  ENDIF
  !
  IPT=0
  NADD=0
  DO I=1,NXGRID
     DO J=1,NYGRID
        DO K=1,NZGRID
           IPT=IPT+1
           IF(MAT(IPT).GE.1) THEN
              NADD=NADD+1
#ifdef KEY_RESIZE
              if (NADD+natom .gt. na0) then
                 na0=nadd+natom+drsz0
                 call resize_psf('modpsf.F90','ADDSRCHAT','NATOM',na0, .true.)
                 call resize_coord('modpsf.F90','ADDSRCHAT',na0, .true.)
                 call resize_coordc('modpsf.F90','ADDSRCHAT',na0, .true.)
                 call resize_deriv('modpsf.F90','ADDSRCHAT',na0, .true.)
              endif
              if (NADD+ngrp .gt. ng0) then
                 ng0=nadd+ngrp+drsz0
                 call resize_psf('modpsf.F90','ADDSRCHAT','NGRP',ng0, .true.)
              endif
#endif    
              !
              IGPBS(NGRP+NADD+1)=NATOM+NADD
              IGPTYP(NGRP+NADD)=0
              IMOVEG(NGRP+NADD)=0
              IAC(NATOM+NADD)=TYPECD
              IMOVE(NATOM+NADD)=0
              ICAAUTO(NATOM+NADD)=15
              IBLO(NATOM+NADD)=IBLO(NATOM)
              ATYPE(NATOM+NADD)='DUM'
              CG(NATOM+NADD)=ZERO
              AMASS(NATOM+NADD)=ARMASS(TYPECD)
              RSCLF(NATOM+NADD)=ONE
#if KEY_WCA==1
              WCA(NATOM+NADD)=ONE          
#endif
              !
              X(NATOM+NADD)=XMAT(I)
              Y(NATOM+NADD)=YMAT(J)
              Z(NATOM+NADD)=ZMAT(K)
              !
           ENDIF
        ENDDO
     ENDDO
  ENDDO
  !
  NATOM=NATOM+NADD
  NGRP=NGRP+NADD
  !
  NRES=NRES+1
#ifdef KEY_RESIZE
  if (natom .lt. na0) &
       call resize_psf('modpsf.F90','ADDSRCHAT','NRES',natom, .true.)
  if (ngrp .lt. ng0) &
       call resize_psf('modpsf.F90','ADDSRCHAT','NGRP',ngrp, .true.)
  call resize_psf('modpsf.F90','ADDSRCHAT','NRES',nres, .true.)
#endif

  if (cnst_is_allocated) call allocate_cnst(natom)
  
  IBASE(NRES+1)=NATOM
  RES(NRES)='DUM'
  RESID(NRES)='1'
  NSEG=NSEG+1
  NICTOT(NSEG+1)=NRES
  SEGID(NSEG)=SID
  !
  ! . Print out the structure file counters.
  CALL PSFSUM(OUTU)
  !
  RETURN
END SUBROUTINE ADDSRCHAT

SUBROUTINE CRENAME(COMLYN,COMLEN)
  !-----------------------------------------------------------------------
  !     THIS ROUTINE RENAMES SEGMENTS, RESIDUES, RESNAMES, ATOM NAMES.
  !
  !     By Bernard R. Brooks  1983
  !
  use dimens_fcm
  use stream
  use psf
  use coord
  use memory
  use select
  use string

  CHARACTER(len=*) :: COMLYN
  INTEGER COMLEN
  INTEGER,allocatable,dimension(:) :: ISLCT
  character(len=4) WRD
  character(len=8) WRD2
  LOGICAL FOUND,GOTIT
  INTEGER ISEG,IRESI,IRESF,IRES,IS,IQ,I
  !
  !
  call chmalloc('charmm_main.src','CRENAME','islct',NATOM,intg=islct)
  WRD=NEXTA4(COMLYN,COMLEN)
  WRD2=NEXTA8(COMLYN,COMLEN)
  CALL SELCTA(COMLYN,COMLEN,ISLCT,X,Y,Z,WMAIN,.TRUE.)
  !
  IF(WRD.EQ.'SEGI') THEN
     GOTIT=.FALSE.
     DO ISEG=1,NSEG
        FOUND=.FALSE.
        IF(WRD2.EQ.SEGID(ISEG)) THEN
           FOUND=.TRUE.
           IF(GOTIT) CALL WRNDIE(0,'<RENAME>', &
                'DUPLICATE SEGID''S ENTERED')
        ENDIF
        IRESI=NICTOT(ISEG)+1
        IRESF=NICTOT(ISEG+1)
        DO IRES=IRESI,IRESF
           IS=IBASE(IRES)+1
           IQ=IBASE(IRES+1)
           DO I=IS,IQ
              IF(ISLCT(I).EQ.1 .AND. .NOT.FOUND) THEN
                 IF(PRNLEV.GE.3) WRITE(OUTU,22) &
                      SEGID(ISEG)(1:idleng),WRD2(1:idleng)
22               FORMAT(' SEGMENT ''',A,''' IS RENAMED TO ''', &
                      A,'''')
                 IF(GOTIT) CALL WRNDIE(0,'<RENAME>', &
                      'DUPLICATE SEGID''S ENTERED')
                 FOUND=.TRUE.
                 SEGID(ISEG)=WRD2
              ENDIF
           ENDDO
        ENDDO
        GOTIT=FOUND .OR. GOTIT
     ENDDO
  ELSE IF(WRD.EQ.'RESI') THEN
     DO ISEG=1,NSEG
        GOTIT=.FALSE.
        IRESI=NICTOT(ISEG)+1
        IRESF=NICTOT(ISEG+1)
        DO IRES=IRESI,IRESF
           FOUND=.FALSE.
           IF(WRD2.EQ.RESID(IRES)) THEN
              FOUND=.TRUE.
              IF(GOTIT) CALL WRNDIE(0,'<RENAME>', &
                   'DUPLICATE RESID''S ENTERED')
           ENDIF
           IS=IBASE(IRES)+1
           IQ=IBASE(IRES+1)
           DO I=IS,IQ
              IF(ISLCT(I).EQ.1 .AND. .NOT.FOUND) THEN
                 IF(PRNLEV.GE.3) WRITE(OUTU,32) &
                      SEGID(ISEG)(1:idleng),RESID(IRES)(1:idleng), &
                      WRD2(1:idleng)
32               FORMAT(' FOR SEGMENT ''',A,''', RESIDUE ''',A, &
                      ''' IS RENAMED',' TO ''',A,'''')
                 IF(GOTIT) CALL WRNDIE(0,'<RENAME>', &
                      'DUPLICATE RESID''S ENTERED')
                 FOUND=.TRUE.
                 RESID(IRES)=WRD2
              ENDIF
           ENDDO
           GOTIT=FOUND .OR. GOTIT
        ENDDO
     ENDDO
  ELSE IF(WRD.EQ.'RESN') THEN
     DO ISEG=1,NSEG
        IRESI=NICTOT(ISEG)+1
        IRESF=NICTOT(ISEG+1)
        DO IRES=IRESI,IRESF
           FOUND=.FALSE.
           IS=IBASE(IRES)+1
           IQ=IBASE(IRES+1)
           DO I=IS,IQ
              IF(ISLCT(I).EQ.1) THEN
                 IF(.NOT.FOUND) THEN
                    IF(PRNLEV.GE.3) WRITE(OUTU,42) &
                         SEGID(ISEG)(1:idleng), &
                         RESID(IRES)(1:idleng), &
                         RES(IRES)(1:idleng),WRD2(1:idleng)
                 ENDIF
42               FORMAT(' FOR SEGMENT ''',A,''' RESIDUE ''',A, &
                      ''', RESNAME ''',A,''' IS RENAMED TO ''', &
                      A,'''')
                 FOUND=.TRUE.
                 RES(IRES)=WRD2
              ENDIF
           ENDDO
        ENDDO
     ENDDO
  ELSE IF(WRD.EQ.'ATOM') THEN
     DO ISEG=1,NSEG
        IRESI=NICTOT(ISEG)+1
        IRESF=NICTOT(ISEG+1)
        DO IRES=IRESI,IRESF
           IS=IBASE(IRES)+1
           IQ=IBASE(IRES+1)
           GOTIT=.FALSE.
           DO I=IS,IQ
              FOUND=.FALSE.
              IF (WRD2 == ATYPE(I)) THEN
                 FOUND=.TRUE.
                 IF(GOTIT) CALL WRNDIE(0,'<RENAME>', &
                      'DUPLICATE ATOMS ENTERED')
              ENDIF
              IF(ISLCT(I).EQ.1 .AND. .NOT.FOUND) THEN
                 IF(PRNLEV.GE.3) WRITE(OUTU,52) &
                      SEGID(ISEG)(1:idleng), &
                      RESID(IRES)(1:idleng), &
                      ATYPE(I)(1:idleng), WRD2(1:idleng)
52               FORMAT(' FOR SEGMENT ''',A,''' RESIDUE ''',A, &
                      ''', ATOM ''',A,''' IS RENAMED TO ''', &
                      A,'''')
                 IF(GOTIT) CALL WRNDIE(0,'<RENAME>', &
                      'DUPLICATE ATOMS ENTERED')
                 FOUND=.TRUE.
                 ATYPE(I)=WRD2
              ENDIF
              GOTIT=FOUND .OR. GOTIT
           ENDDO
        ENDDO
     ENDDO
  ELSE
     CALL WRNDIE(0,'<RENAME>','UNRECOGNIZED RENAME OPTION')
  ENDIF
  !
  call chmdealloc('charmm_main.src','CRENAME','islct',NATOM,intg=islct)
  RETURN
END SUBROUTINE CRENAME

SUBROUTINE JOINSG(COMLYN,COMLEN)
  !-----------------------------------------------------------------------
  !     THIS ROUTINE JOINS TWO ADJACENT SEGMENTS TOGETHER.
  !     ITS PRIMARY USE IS IN MODIFYING A PSF FOR USE WITH IMAGES.
  !     NO CHECK OF RESID'S IS MADE, BUT A RENUMBER OPTION IS AVAILABLE.
  !           BRB  10-DEC-1983
  !
  use dimens_fcm
  use stream
  use psf
  use string
#ifdef KEY_RESIZE
  use resize
#endif

  character(len=*) COMLYN
  INTEGER COMLEN
  !
  character(len=8) WRD
  LOGICAL LRENUM,OK
  INTEGER ISEG,I,IS,IQ,JUNK
  !
  IF(NSEG.NE.NSEGT) THEN
     CALL WRNDIE(-2,'<JOINSG>','CANT JOIN WITH IMAGES PRESENT')
     RETURN
  ENDIF
  !
  LRENUM=INDXA(COMLYN,COMLEN,'RENU').GT.0
  !
  WRD=NEXTA8(COMLYN,COMLEN)
  ISEG=-1
  DO I=1,NSEG
     IF(WRD.EQ.SEGID(I)) ISEG=I
  ENDDO
  IF(ISEG.LT.0) THEN
     CALL WRNDIE(-1,'<JOINSG>','CANT FIND FIRST SEGMENT')
     RETURN
  ENDIF
  !
  WRD=NEXTA8(COMLYN,COMLEN)
  OK=ISEG.LT.NSEG
  IF(OK) OK=SEGID(ISEG+1).EQ.WRD
  IF(.NOT.OK) THEN
     IF(LRENUM .AND. WRD.EQ.' ') THEN
        GOTO 100
     ELSE
        CALL WRNDIE(-1,'<JOINSG>', &
             'SECOND SEGMENT DOESNT FOLLOW FIRST')
     ENDIF
     RETURN
  ENDIF
  !
  !
  NSEG=NSEG-1
  NSEGT=NSEG
  DO I=ISEG+1,NSEG
     SEGID(I)=SEGID(I+1)
     NICTOT(I)=NICTOT(I+1)
  ENDDO
  NICTOT(NSEG+1)=NICTOT(NSEG+2)
  IF(PRNLEV.GE.2) WRITE(OUTU,22) SEGID(ISEG)(1:idleng),WRD(1:idleng)
22 FORMAT(' SEGMENTS "',A,'" AND "',A,'" HAVE BEEN JOINED.')
  !
100 CONTINUE
  IF(LRENUM) THEN
     IF(PRNLEV.GE.2) WRITE(OUTU,23)
23   FORMAT(' THE RESIDUE IDENTIFIERS HAVE BEEN RENUMBERED')
     IS=NICTOT(ISEG)+1
     IQ=NICTOT(ISEG+1)
     DO I=IS,IQ
        CALL ENCODI(I-IS+1,RESID(I),8,JUNK)
     ENDDO
  ENDIF
  !yw...09-May-97, set ?NSEG by calling PSFSUM
  CALL PSFSUM(OUTU)
#ifdef KEY_RESIZE
  call resize_psf('modpsf.F90','JOINSG','NSEG',nseg, .true.)
#endif      
  !
  RETURN
END SUBROUTINE JOINSG

end module modpsf

