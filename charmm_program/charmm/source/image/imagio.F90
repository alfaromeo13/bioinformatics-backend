SUBROUTINE IMREAD(COMLYN,COMLEN,IUNIT,LPRINT)
  !
  !     THIS ROUTINE READS THE IMAGE DATA FILE FROM CARDS
  !
  !     By Bernard R. Brooks    9/83
  !
  use chm_kinds
  use dimens_fcm
  use bases_fcm
  use image
  use psf
  use stream
  use ctitla
  use code,only:mustup
  use string
  use image_routines_module,only: INIMAG,REIMAG
  use upimag_util,only: IMAUTGEN
  implicit none
  !
  character(len=*) COMLYN
  INTEGER COMLEN,IUNIT
  LOGICAL LPRINT
  !
  character(len=4) WINIT
  integer j
  logical QAPPE, QAUTOG, QREMDUP, QSORT
  !
  !
  !
  !     READ IMAGE PSF

     IF(INDXA(COMLYN,COMLEN,'PSF').GT.0) THEN
       QAPPE=(INDXA(COMLYN,COMLEN,'APPE').GT.0)

       QAUTOG=.NOT.(INDXA(COMLYN,COMLEN,'NOAU').GT.0)
       IF(INDXA(COMLYN,COMLEN,'AUTO').GT.0) QAUTOG=.TRUE.
       QREMDUP=.NOT.(INDXA(COMLYN,COMLEN,'NORE').GT.0)
       IF(INDXA(COMLYN,COMLEN,'REMD').GT.0) QREMDUP=.TRUE.
       QSORT=(INDXA(COMLYN,COMLEN,'SORT').GT.0)
       IF(QREMDUP) QSORT=.TRUE.



       CALL IMPSFRD(IUNIT,NTRANS,IMNAME,BIMAG%IMATTR,BIMAG%IMATPT, &
          SEGID,RES,RESID,IBASE,ATYPE,NICTOT, &
          IB(NBOND+1),JB(NBOND+1),ICBAUTO(NBOND+1), &
          IT(NTHETA+1),JT(NTHETA+1),KT(NTHETA+1), &
          IP(NPHI+1),JP(NPHI+1),KP(NPHI+1),LP(NPHI+1),IPAUTO(NPAUTO+1), &
          JPAUTO(NPAUTO+1),KPAUTO(NPAUTO+1),LPAUTO(NPAUTO+1),ICPAUTO(NPAUTO+1), &
          IM(NIMPHI+1),JM(NIMPHI+1),KM(NIMPHI+1),LM(NIMPHI+1), &
#if KEY_CMAP==1
          I1CT(NCRTERM+1),J1CT(NCRTERM+1),K1CT(NCRTERM+1),L1CT(NCRTERM+1), & 
          I2CT(NCRTERM+1),J2CT(NCRTERM+1),K2CT(NCRTERM+1),L2CT(NCRTERM+1), & 
          NIMCRT, &   
#endif
          NIMBON,NIMANG,NIMDIH,NIMAUTO,NIMIMP,NSEG,NRES,NATOM,QAPPE)
       
       NBONDT=NBOND+NIMBON
       NBONDT2=NBONDT ! hwm220722
       NTHETT=NTHETA+NIMANG
       NPHIT =NPHI+NIMDIH
       NPAUTOT=NPAUTO+NIMAUTO
       NIMPHT=NIMPHI+NIMIMP
#if KEY_CMAP==1
       NCRTT=NCRTERM+NIMCRT 
#endif

  !  Autogenerate image angles and dihedrals, if requested. 
  !  Update image exclusion list
         CALL IMAUTGEN(QAUTOG,QREMDUP,QSORT)

#if KEY_CMAP==1
       J=NIMCRT 
#else /**/
       J=0
#endif
       IF(PRNLEV.GE.2) WRITE(OUTU,701) NATIM-NATOM,NIMBON,NIMANG, &
                                       NIMDIH,NIMAUTO,NIMIMP,J,NIMEXCL

701    FORMAT(10X,'CURRENT IMAGE INTERNAL COORDINATE COUNTS:'/ &
          10X,'NATOM   NBOND   NTHETA  NPHI   NPAUTO  NIMPHI  NCRT    NEXCL'/7X,9I8)

       MUSTUP = .TRUE.
       WINIT='RESE'
       J=4
       CALL GTNBCT(WINIT,J,BNBND)

       RETURN
     ENDIF
 !
 !
 !     READ IMAGE TRANSFORMATIONS
 !
     J=INDXA(COMLYN,COMLEN,'TRAN')
     IF(INDXA(COMLYN,COMLEN,'INIT') > 0) CALL INIMAG(BIMAG,.TRUE.)
     IF(NTRANS == 0) CALL REIMAG(BIMAG,0,0)
 !
 !
     CALL IMREAD2(COMLYN,COMLEN,IUNIT,LPRINT)
 !
     RETURN
END SUBROUTINE IMREAD


SUBROUTINE IMREAD2(COMLYN,COMLEN,IUNIT,LPRINT)
  !
  !     THIS ROUTINE READS THE IMAGE DATA FILE FROM CARDS
  !
  !     By Bernard R. Brooks    9/83
  !
  use chm_kinds
  use dimens_fcm
  use vector
  use image
  use stream
  use ctitla
  use corsubs,only:fndrot,fndu
  use string
  implicit none
  !
  character(len=*) COMLYN
  INTEGER COMLEN,IUNIT
  LOGICAL LPRINT
  !
  real(chm_real) SCALE(3),U(9)
  LOGICAL DONE,EOF,INVERT
  !
  real(chm_real) PHI,PHIX
  real(chm_real) UA(3,3),UB(3,3),UC(3,3)
  real(chm_real) TA(3),TB(3),TC(3),TBX(3)
  INTEGER I,ITRANS,IPT
  real(chm_real) UNCHK,YT,ZT,XT,UX,DIST
  INTEGER JTRANS,JPT,K,J,L,II,JJ,IPTX,NT
  LOGICAL LOK
  character(len=4) WRD
  character(len=8) WRD8
  !
  !
  !     READ TRANSFORMATION INFORMATION FROM CARDS
  !
  CALL TRYORO(IUNIT,'FORMATTED')
  !
  !
  CALL RDTITL(TITLEB,NTITLB,IUNIT,0)
  IF(PRNLEV.GE.2) WRITE(OUTU,13) IUNIT
13 FORMAT(/12X,' READING IMAGE FILE FROM UNIT',I5/)
  !
  NTRANS=0
  SCALE(1)=1.0
  SCALE(2)=1.0
  SCALE(3)=1.0
  !
  EOF=.FALSE.
  DONE=.FALSE.
5000 CONTINUE
  !
  CALL RDCMND(COMLYN,MXCMSZ,COMLEN,IUNIT,EOF,.TRUE., &
       LPRINT,'IMREAD> ')
  IF(EOF) DONE=.TRUE.
  !
  WRD=NEXTA4(COMLYN,COMLEN)
  IF (WRD.EQ.'IMAG') THEN
     !       Begin Procedure PROCESS-IMAGE-COMMAND
     !
     IF(LPRINT .AND. PRNLEV.GE.2 .AND. NTRANS.GT.0) THEN
        !         print out the transformation just finished
        WRITE(OUTU,39) NTRANS,IMNAME(NTRANS)
39      FORMAT(/' TRANSFORMATION',I4,'  NAME:  ',A)
        IPT=(NTRANS-1)*12+1
        DO J=1,4
           IPTX=IPT+2
           WRITE(OUTU,6) (IMTRNS(K),K=IPT,IPTX)
6          FORMAT(20X,3F10.6)
           IPT=IPT+3
        ENDDO
     ENDIF
     !
     NT=NTRANS+1
     IF(NT.GT.MAXTRN) CALL WRNDIE(-2,'<IMREAD>', &
          'OVERFLOW IN NUMBER OF TRANSFORMATIONS')
     WRD8=NEXTA8(COMLYN,COMLEN)
     DO I=1,NTRANS
        IF(WRD8.EQ.IMNAME(I)) &
             CALL WRNDIE(-2,'<IMREAD>','DUPLICATE TRANSFORMATION NAME')
     ENDDO
     IMNAME(NT)=WRD8
     IPT=(NT-1)*12
     DO I=1,12
        IMTRNS(IPT+I)=0.0
     ENDDO
     IMTRNS(IPT+1)=1.0
     IMTRNS(IPT+5)=1.0
     IMTRNS(IPT+9)=1.0
     NTRANS=NT
     !       End Procedure PROCESS-IMAGE-COMMAND
  ELSE IF (WRD.EQ.'DEFI') THEN
     !       Begin Procedure PROCESS-DEFINE-COMMAND
     INVERT=.FALSE.
6000 CONTINUE
     WRD8=NEXTA8(COMLYN,COMLEN)
     IF (WRD8.EQ.' ') THEN
     ELSE IF (WRD8(1:4).EQ.'INVE') THEN
        INVERT=.TRUE.
     ELSE 
        !
        !         FIND FORMER TRANSFORMATION
        !
        DO ITRANS=1,NTRANS
           IF(WRD8.EQ.IMNAME(ITRANS)) GOTO 200
        ENDDO
        IF(WRNLEV.GE.2) WRITE(OUTU,192) WRD8
192     FORMAT(/' TRANSFORMATION NAME ''',A,''' NOT FOUND')
        CALL WRNDIE(-3,'<IMREAD>', &
             'NAME NOT FOUND, RESET TO FIRST ONE')
        ITRANS=1
200     CONTINUE
        IPT=(ITRANS-1)*12
        DO I=1,3
           DO J=1,3
              IPT=IPT+1
              UB(J,I)=IMTRNS(IPT)
           ENDDO
        ENDDO
        !
        DO I=1,3
           IPT=IPT+1
           TB(I)=IMTRNS(IPT)
        ENDDO
        IF(INVERT) THEN
           !
           !           INVERT TRANSLATION VECTOR (AND ROTATE)
           DO I=1,3
              TC(I)=0.0
              DO J=1,3
                 TC(I)=TC(I)-TB(J)*UB(I,J)
              ENDDO
           ENDDO
           !           TC(1)=-(TB(1)*UB(1,1)+TB(2)*UB(1,2)+TB(3)*UB(1,3))
           !           TC(2)=-(TB(1)*UB(2,1)+TB(2)*UB(2,2)+TB(3)*UB(2,3))
           !           TC(3)=-(TB(1)*UB(3,1)+TB(2)*UB(3,2)+TB(3)*UB(3,3))
           TB(1)=TC(1)
           TB(2)=TC(2)
           TB(3)=TC(3)
           !
           !           INVERT ROTATION MATRIX
           DO I=1,3
              DO J=1,I
                 UX=UB(J,I)
                 UB(J,I)=UB(I,J)
                 UB(I,J)=UX
              ENDDO
           ENDDO
        ENDIF
        !
        !         MULTIPLY-TRANSFORMATIONS
        CALL MULTTR(TA,TB,TC,UA,UB,UC)
        !
        INVERT=.FALSE.
     ENDIF
     IF (WRD8.NE.' ') GOTO 6000
     !       End Procedure PROCESS-DEFINE-COMMAND
  ELSE IF (WRD.EQ.'SCAL') THEN
     !       Begin Procedure PROCESS-SCALE-COMMAND
     SCALE(1)=NEXTF(COMLYN,COMLEN)
     SCALE(2)=NEXTF(COMLYN,COMLEN)
     SCALE(3)=NEXTF(COMLYN,COMLEN)
     !       End Procedure PROCESS-SCALE-COMMAND
  ELSE IF (WRD.EQ.'ROTA') THEN
     !       Begin Procedure PROCESS-ROTA-COMMAND
     DO I=1,3
        TB(I)=NEXTF(COMLYN,COMLEN)
     ENDDO
     CALL NORMALL(TB,3)
     PHI=NEXTF(COMLYN,COMLEN)
     CALL FNDU(UB,TB,PHI,LOK)
     IF (.NOT.LOK) THEN
        !         Begin Procedure CRAP-OUT
        IF(WRNLEV.GE.2) WRITE(OUTU,925)
925     FORMAT(/' ***** ERROR ***** <IMREAD> PARSING ERROR.'/)
        CALL DIEWRN(0)
        RETURN
        !         End Procedure CRAP-OUT
     ENDIF
     !
     TB(1)=0.0
     TB(2)=0.0
     TB(3)=0.0
     !       MULTIPLY-TRANSFORMATIONS
     CALL MULTTR(TA,TB,TC,UA,UB,UC)
     IF(LPRINT .AND. PRNLEV.GE.2) THEN
        WRITE(OUTU,61) UB
61      FORMAT(' ROTATION MATRIX'/,3(3F12.6/))
        CALL FNDROT(UB,TBX,PHIX,LPRINT)
     ENDIF
     !       End Procedure PROCESS-ROTA-COMMAND
  ELSE IF (WRD.EQ.'TRAN') THEN
     !       Begin Procedure PROCESS-TRAN-COMMAND
     TB(1)=NEXTF(COMLYN,COMLEN)
     TB(2)=NEXTF(COMLYN,COMLEN)
     TB(3)=NEXTF(COMLYN,COMLEN)
     !
     CALL TRIME(COMLYN,COMLEN)
     IF(COMLEN.GT.0) THEN
        DIST=NEXTF(COMLYN,COMLEN)
        CALL NORMALL(TB,3)
        TB(1)=TB(1)*DIST
        TB(2)=TB(2)*DIST
        TB(3)=TB(3)*DIST
     ENDIF
     !
     TB(1)=TB(1)*SCALE(1)
     TB(2)=TB(2)*SCALE(2)
     TB(3)=TB(3)*SCALE(3)
     IPT=(NTRANS-1)*12+9
     IMTRNS(IPT+1)=IMTRNS(IPT+1)+TB(1)
     IMTRNS(IPT+2)=IMTRNS(IPT+2)+TB(2)
     IMTRNS(IPT+3)=IMTRNS(IPT+3)+TB(3)
     IF(LPRINT .AND. PRNLEV.GE.2) WRITE(OUTU,71) TB
71   FORMAT(' TRANSLATION VECTOR ',3F12.6)
     !       End Procedure PROCESS-TRAN-COMMAND
  ELSE IF (WRD.EQ.'NEGA') THEN
     !       Begin Procedure PROCESS-NEGATE-COMMAND
     DO I=1,3
        DO J=1,3
           UB(I,J)=0.0
        ENDDO
        UB(I,I)=-1.0
        TB(I)=0.0
     ENDDO
     !       MULTIPLY-TRANSFORMATIONS
     CALL MULTTR(TA,TB,TC,UA,UB,UC)
     !       End Procedure PROCESS-NEGATE-COMMAND
  ELSE IF (WRD.EQ.'END ') THEN
     !       Begin Procedure PROCESS-END-COMMAND
     DONE=.TRUE.
     !       End Procedure PROCESS-END-COMMAND
  ELSE IF (WRD.EQ.'    ') THEN
  ELSE
     CALL WRNDIE(0,'<IMREAD>','Unrecognized command')
  ENDIF
  !
  CALL XTRANE(COMLYN,COMLEN,'IMREAD')
  !
  IF (.NOT.DONE) GOTO 5000
  !
  !     Begin Procedure CHECK-ALL-TRANSFORMATIONS
  !
  DO ITRANS=1,NTRANS
     IPT=(ITRANS-1)*12
     UNCHK=0.0
     UNCHK=UNCHK+IMTRNS(IPT+1)*IMTRNS(IPT+5)*IMTRNS(IPT+9)
     UNCHK=UNCHK-IMTRNS(IPT+1)*IMTRNS(IPT+6)*IMTRNS(IPT+8)
     UNCHK=UNCHK+IMTRNS(IPT+2)*IMTRNS(IPT+6)*IMTRNS(IPT+7)
     UNCHK=UNCHK-IMTRNS(IPT+2)*IMTRNS(IPT+4)*IMTRNS(IPT+9)
     UNCHK=UNCHK+IMTRNS(IPT+3)*IMTRNS(IPT+4)*IMTRNS(IPT+8)
     UNCHK=UNCHK-IMTRNS(IPT+3)*IMTRNS(IPT+5)*IMTRNS(IPT+7)
     IF(ABS(ABS(UNCHK)-1.0).GT.1.D-4) THEN
        IF(WRNLEV.GE.2) WRITE(OUTU,85) ITRANS,UNCHK
85      FORMAT(/' WARNING: TRANSFORMATION MATRIX',I4, &
             ' IS NOT UNITARY', &
             /'      DETERMINANT IS  ',F14.8/)
        CALL DIEWRN(-2)
     ENDIF
     IF(UNCHK.LT.0.0) THEN
        IF(PRNLEV.GE.2) WRITE(OUTU,23) ITRANS,IMNAME(ITRANS)
23      FORMAT(' TRANSFORMATION',I5,2X,A,' IS A MIRROR REFLECTION')
     ENDIF
  ENDDO
  !
  IF(PRNLEV.GE.2) WRITE(OUTU,125) NTRANS
125 FORMAT(/I6,'  TRANSFORMATIONS HAVE BEEN READ'/)
  NOROT=.TRUE.
  !
  loop9k:DO ITRANS=1,NTRANS
     IPT=(ITRANS-1)*12
     loop8k:DO JTRANS=1,NTRANS
        JPT=(JTRANS-1)*12
        YT=IMTRNS(IPT+10)*IMTRNS(JPT+4)+IMTRNS(IPT+11)*IMTRNS(JPT+5)+ &
             IMTRNS(IPT+12)*IMTRNS(JPT+6)+IMTRNS(JPT+11)
        ZT=IMTRNS(IPT+10)*IMTRNS(JPT+7)+IMTRNS(IPT+11)*IMTRNS(JPT+8)+ &
             IMTRNS(IPT+12)*IMTRNS(JPT+9)+IMTRNS(JPT+12)
        XT=IMTRNS(IPT+10)*IMTRNS(JPT+1)+IMTRNS(IPT+11)*IMTRNS(JPT+2)+ &
             IMTRNS(IPT+12)*IMTRNS(JPT+3)+IMTRNS(JPT+10)
        UNCHK=XT*XT+YT*YT+ZT*ZT
        IF(UNCHK.LE.1.D-4) THEN
           !
           K=0
           DO I=1,3
              DO J=1,3
                 K=K+1
                 U(K)=0.0
                 DO L=1,3
                    II=IPT+3*J+L-3
                    JJ=JPT+3*L+I-3
                    U(K)=U(K)+IMTRNS(II)*IMTRNS(JJ)
                 ENDDO
              ENDDO
           ENDDO
           !
           U(1)=U(1)-1.0
           U(5)=U(5)-1.0
           U(9)=U(9)-1.0
           UNCHK=0.0
           DO I=1,9
              UNCHK=UNCHK+U(I)*U(I)
           ENDDO
           IF(UNCHK.LE.0.001) THEN
              IMINV(ITRANS)=JTRANS
              GOTO 170
           ENDIF
        ENDIF
     enddo loop8k
     !
     IF(WRNLEV.GE.2) WRITE(OUTU,185) ITRANS
185  FORMAT(/' WARNING: TRANSFORMATION NUMBER',I4, &
          '  HAS NO INVERSE'/)
     IMINV(ITRANS)=0
     CALL DIEWRN(-3)
     !
170  CONTINUE
     DO I=1,9
        J=I+IPT
        U(I)=IMTRNS(J)
     ENDDO
     U(1)=U(1)-1.0
     U(5)=U(5)-1.0
     U(9)=U(9)-1.0
     UNCHK=0.0
     DO I=1,9
        UNCHK=UNCHK+U(I)*U(I)
     ENDDO
     IF(UNCHK.GT.0.001) NOROT=.FALSE.
     !
  enddo loop9k
  !
  IF(PRNLEV.GE.2) THEN
     IF (NOROT) THEN
        WRITE(OUTU,'(20X,A)') &
             ' THERE ARE NO ROTATIONS FOR THIS TRANSFORMATION SET'
     ELSE
        WRITE(OUTU,'(20X,A)') &
             ' THERE ARE ROTATIONS FOR THIS TRANSFORMATION SET'
     ENDIF
  ENDIF
  !
  !     End Procedure CHECK-ALL-TRANSFORMATIONS
  RETURN
  !
END SUBROUTINE IMREAD2

SUBROUTINE MULTTR(TA,TB,TC,UA,UB,UC)
  !
  !     TO MULTIPLY-TRANSFORMATIONS
  !
  !     UA  =  UB  X  UC
  !
  use chm_kinds
  use dimens_fcm
  use number
  !
  use image
  implicit none
  !
  real(chm_real) UA(3,3),UB(3,3),UC(3,3)
  real(chm_real) TA(3),TB(3),TC(3)
  !
  !     local
  !
  INTEGER I,IPT,J,K
  !
  IPT=(NTRANS-1)*12
  DO I=1,3
     DO J=1,3
        IPT=IPT+1
        UC(J,I)=IMTRNS(IPT)
     ENDDO
  ENDDO
  !
  DO I=1,3
     IPT=IPT+1
     TC(I)=IMTRNS(IPT)
  ENDDO
  !
  DO I=1,3
     DO J=1,3
        UA(J,I)=ZERO
        DO K=1,3
           UA(J,I)=UA(J,I)+UB(K,I)*UC(J,K)
        ENDDO
     ENDDO
  ENDDO
  !
  DO I=1,3
     TA(I)=TB(I)
     DO K=1,3
        TA(I)=TA(I)+UB(K,I)*TC(K)
     ENDDO
  ENDDO
  !
  IPT=IPT-12
  DO I=1,3
     DO J=1,3
        IPT=IPT+1
        IMTRNS(IPT)=UA(J,I)
     ENDDO
  ENDDO
  DO I=1,3
     IPT=IPT+1
     IMTRNS(IPT)=TA(I)
  ENDDO
  !
  RETURN
END SUBROUTINE MULTTR

SUBROUTINE IMWRIT(IUNIT,COMLYN,COMLEN,BIMAG,IPRINT)
  !
  !     THIS ROUTINE WRITES IN CARD IMAGE OR PRINTS THE IMAGE DATA FILE
  !
  !     By Bernard R. Brooks    9/83
  !
  use chm_kinds
  use chm_types
  use dimens_fcm
  use exfunc
  use psf
  use image
  use stream
  use ctitla
  use string

  !
  implicit none
  !
  character(len=*) COMLYN
  INTEGER IUNIT,COMLEN,IPRINT
  type(imageDataStructure) BIMAG
  !
  INTEGER I,ITRANS,IPT,J,IPTX,K
  character(len=4) WRD
  real(chm_real) TOTF(3),TOTT(3)
  logical QBYNUM
  !
  WRD=NEXTA4(COMLYN,COMLEN)

  IF (WRD.EQ.'PSF ') THEN

     QBYNUM=.false.
     IF(INDXA(COMLYN,COMLEN,'BYNU').GT.0) QBYNUM=.TRUE.
     IF(INDXA(COMLYN,COMLEN,'NAMI').GT.0) QBYNUM=.FALSE.

     IF(QBYNUM) THEN   
!  use the old bynumber format
       CALL IMPSFPR(IUNIT,NTRANS,IMNAME,IMINV, &
          BIMAG%IMATPT, &
          RES,RESID,IBASE,ATYPE,CG,AMASS,IAC,ICAAUTO, &
          IMOVE,IB(NBOND+1),JB(NBOND+1),ICBAUTO(NBOND+1), &
          IT(NTHETA+1),JT(NTHETA+1),KT(NTHETA+1), &
          IP(NPHI+1),JP(NPHI+1),KP(NPHI+1),LP(NPHI+1),IPAUTO(NPAUTO+1), &
          JPAUTO(NPAUTO+1),KPAUTO(NPAUTO+1),LPAUTO(NPAUTO+1),ICPAUTO(NPAUTO+1), &
          IM(NIMPHI+1),JM(NIMPHI+1),KM(NIMPHI+1),LM(NIMPHI+1), &
#if KEY_CMAP==1
          I1CT(NCRTERM+1),J1CT(NCRTERM+1),K1CT(NCRTERM+1),L1CT(NCRTERM+1), & 
          I2CT(NCRTERM+1),J2CT(NCRTERM+1),K2CT(NCRTERM+1),L2CT(NCRTERM+1), & 
          NIMCRT, &   
#endif
          BIMAG%NIMINB,BIMAG%IMINB,BIMAG%IMIBLO, &
          NIMRES,NIMGRP,NATIM,NIMBON,NIMANG,NIMDIH,NIMAUTO,NIMIMP, &
          NRES,NATOM,NGRP,IGPBS,IGPTYP,IMOVEG)
     ELSE
!  use the new bynaming format
       CALL IMPSFWR(IUNIT,NTRANS,IMNAME,BIMAG%IMATTR,BIMAG%IMATPT, &
          SEGID,RES,RESID,IBASE,ATYPE,NICTOT, &
          IB(NBOND+1),JB(NBOND+1),ICBAUTO(NBOND+1), &
          IT(NTHETA+1),JT(NTHETA+1),KT(NTHETA+1), &
          IP(NPHI+1),JP(NPHI+1),KP(NPHI+1),LP(NPHI+1),IPAUTO(NPAUTO+1), &
          JPAUTO(NPAUTO+1),KPAUTO(NPAUTO+1),LPAUTO(NPAUTO+1),ICPAUTO(NPAUTO+1), &
          IM(NIMPHI+1),JM(NIMPHI+1),KM(NIMPHI+1),LM(NIMPHI+1), &
#if KEY_CMAP==1
          I1CT(NCRTERM+1),J1CT(NCRTERM+1),K1CT(NCRTERM+1),L1CT(NCRTERM+1), & 
          I2CT(NCRTERM+1),J2CT(NCRTERM+1),K2CT(NCRTERM+1),L2CT(NCRTERM+1), & 
          NIMCRT, &   
#endif
          NIMEXCL,IMEXCLI,IMEXCLJ,IMEXCLT, &
          NIMBON,NIMANG,NIMDIH,NIMAUTO,NIMIMP,NSEG,NRES,NATOM)
     ENDIF      

  ELSE IF (WRD.EQ.'FORC') THEN
     !       Begin Procedure PRINT-IMAGE-FORCES
     !
     DO I=1,3
        TOTT(I)=0.0
        TOTF(I)=0.0
     ENDDO
     !
     DO ITRANS=1,NTRANS
        IPT=(ITRANS-1)*3
        WRITE(IUNIT,734) ITRANS,IMNAME(ITRANS), &
             (IMFORC(IPT+J),J=1,3),(IMTORQ(IPT+J),J=1,3)
734     FORMAT(' TRANSFORMATION',I5,2X,A/, &
             '   FORCES:',3F16.6/'   TORQUE:',3F16.6)
        DO J=1,3
           TOTT(J)=TOTT(J)+IMTORQ(IPT+J)
           TOTF(J)=TOTF(J)+IMFORC(IPT+J)
        ENDDO
     ENDDO
     !
     WRITE(IUNIT,735) (TOTF(J),J=1,3),(TOTT(J),J=1,3)
735  FORMAT(' TOTAL'/,'   FORCES:',3F16.6/'   TORQUE:',3F16.6)
     !       End Procedure PRINT-IMAGE-FORCES

  ELSE IF (WRD.EQ.'TRAN') THEN
     !       Begin Procedure PRINT-IMAGE-TRANSFORMATIONS
     CALL WRTITL(TITLEA,NTITLA,IUNIT,1)
     WRITE(IUNIT,37) NTRANS
37   FORMAT(/' NUMBER OF TRANSFORMATIONS IS',I4)
     IPT=1
     DO I=1,NTRANS
        WRITE(IUNIT,39) I,IMNAME(I),IMINV(I)
39      FORMAT(/' TRANSFORMATION',I4,'  NAME:  ',A,'  INVERSE',I4)
        DO J=1,4
           IPTX=IPT+2
           WRITE(IUNIT,6) (IMTRNS(K),K=IPT,IPTX)
6          FORMAT(20X,3F10.6)
           IPT=IPT+3
        ENDDO
     ENDDO
     !       End Procedure PRINT-IMAGE-TRANSFORMATIONS
  ELSE IF (WRD.EQ.'    ') THEN
     CONTINUE
  ELSE
     IF(WRNLEV.GE.0) WRITE(OUTU,77) WRD
77   FORMAT('IMWRIT: Unable to write IMAGE file type: "',A4,'".')
     CALL WRNDIE(0,'<IMWRIT>','Unrecognized IMAGE file type')
  ENDIF
  !
  CALL XTRANE(COMLYN,COMLEN,'IMWRIT')
  RETURN
  !
END SUBROUTINE IMWRIT

SUBROUTINE IMPSFPR(IUNIT,NTRANS,IMNAME,IMINV,IMATPT, &
     RES,RESID,IBASE,ATYPE,CG,AMASS,IAC,ICAAUTO, &
     IMOVE,IB,JB,ICBAUTO,IT,JT,KT,IP,JP,KP,LP, &
     IPAUTO,JPAUTO,KPAUTO,LPAUTO,ICPAUTO,IM,JM,KM,LM, &
#if KEY_CMAP==1
     I1CT,J1CT,K1CT,L1CT,I2CT,J2CT,K2CT,L2CT,NIMCRT, &   
#endif
     NIMINB,IMINB,IMIBLO, &
     NIMRES,NIMGRP,NATIM,NIMBON,NIMANG,NIMDIH,NIMAUTO,NIMIMP, &
     NRES,NATOM,NGRP,IGPBS,IGPTYP,IMOVEG)
  !
  !     THIS ROUTINE PRINTS THE PSF FOR IMAGE ATOMS.
  !  It uses the old format and includes atom info and active exclusions.
  !
  use chm_kinds
  use exfunc
  use stream
  implicit none
  !
  INTEGER IUNIT,NTRANS,IMINV(*)
  character(len=*) IMNAME(*)
  INTEGER     IMATPT(*)
  real(chm_real)      CG(*),AMASS(*)
  character(len=*) RES(*),RESID(*),ATYPE(*)
  INTEGER     IBASE(*),IAC(*), ICAAUTO(*)
  INTEGER     IMOVE(*),IB(*),JB(*),ICBAUTO(*)
  INTEGER     IT(*),JT(*),KT(*)
  INTEGER     IP(*),JP(*),KP(*),LP(*)
  INTEGER     IPAUTO(*),JPAUTO(*),KPAUTO(*),LPAUTO(*),ICPAUTO(*)
  INTEGER     IM(*),JM(*),KM(*),LM(*)
  INTEGER     IMINB(*),IMIBLO(*)
#if KEY_CMAP==1
  INTEGER I1CT(*),J1CT(*),K1CT(*),L1CT(*)
  INTEGER I2CT(*),J2CT(*),K2CT(*),L2CT(*)
  INTEGER NIMCRT
#endif 
  INTEGER NIMRES(*),NIMGRP,NATIM,NIMBON,NIMANG,NIMDIH,NIMAUTO,NIMIMP
  INTEGER NRES,NATOM,NGRP,NIMINB
  INTEGER IGPBS(*),IGPTYP(*),IMOVEG(*)
  !
  INTEGER ITRANS,NEXTT,IRES,IGRP,I,INV,IS,IW,J

  I=0
#if KEY_CMAP==1
    I=NIMCRT  
#endif
  WRITE(IUNIT,40) NATIM,NIMBON,NIMANG,NIMDIH,NIMAUTO,NIMIMP,I, &
       NIMINB,NIMRES(NTRANS),NTRANS,NIMGRP

40 FORMAT(/9X,'NATIM  NIMBON NIMANG NIMDIH NIMAUTO NIMIMP NIMCRT ', &
       'NIMINB NIMRES NTRANS NIMGRP'/7X,13I7)

  WRITE(IUNIT,105)
105 FORMAT(/10X,'ATOM CHARACTERISTICS :'/19X,'ATOM TYPE      ', &
       'CHARGE    ATOM CODE   COUNT OF    MOVEMENT FLAG', &
       '        MASS'/56X,'EXCLUSIONS'/)

  ITRANS=0
  NEXTT=0
  IRES=NRES+1
  IGRP=NGRP+1

50 FORMAT(' TRANSFORMATION',I4,2X,A,'  INVERSE',I4,2X,A)
108 FORMAT('     RESIDUE',I4,2X,A,2X,A,8X,'  TO',I6)
109 FORMAT(10X,'GROUP',I4,'  TYPE',I3,' MOVE',I2,'  TO',I6)
110 FORMAT(20X,I5,2X,A,F12.4,I5,I6,I5,1PG14.6,I4)
  DO I=NATOM+1,NATIM
     IF(I.GT.NEXTT) THEN
        ITRANS=ITRANS+1
        NEXTT=IMATPT(ITRANS)
        INV=IMINV(ITRANS)
        WRITE(IUNIT,50) ITRANS,IMNAME(ITRANS),INV,IMNAME(INV)
     ENDIF
     IF(IBASE(IRES)+1.EQ.I) THEN
        WRITE(IUNIT,108) IRES,RESID(IRES)(1:idleng), &
             RES(IRES)(1:idleng),IBASE(IRES+1)
        IRES=IRES+1
     ENDIF
     IF(IGPBS(IGRP)+1.EQ.I) THEN
        WRITE(IUNIT,109) IGRP,IGPTYP(IGRP),IMOVEG(IGRP),IGPBS(IGRP+1)
        IGRP=IGRP+1
     ENDIF
     WRITE(IUNIT,110) I,ATYPE(I)(1:idleng),CG(I),IAC(I),IMIBLO(I), &
          IMOVE(I),AMASS(I),ICAAUTO(I)
  ENDDO

  WRITE(IUNIT,'(/10X,A)') 'BOND ARRAY (BY COLUMNS) :'
  DO I=1,NIMBON,20
     IS=I
     IW=I+19
     IF(IW.GT.NIMBON) IW=NIMBON
     WRITE(IUNIT,70) I,(IB(J),J=IS,IW)
     WRITE(IUNIT,160) (JB(J),J=IS,IW)
     WRITE(IUNIT,160) (ICBAUTO(J),J=IS,IW)
  ENDDO

  WRITE(IUNIT,'(/10X,A)') 'THETA ARRAY (BY COLUMNS) :'
  DO I=1,NIMANG,20
     IS=I
     IW=I+19
     IF(IW.GT.NIMANG) IW=NIMANG
     WRITE(IUNIT,70) I,(IT(J),J=IS,IW)
     WRITE(IUNIT,160) (JT(J),J=IS,IW)
     WRITE(IUNIT,160) (KT(J),J=IS,IW)
  ENDDO

  WRITE(IUNIT,'(/10X,A)') 'PHI ARRAY (BY COLUMNS) :'
  DO I=1,NIMDIH,20
     IS=I
     IW=I+19
     IF(IW.GT.NIMDIH) IW=NIMDIH
     WRITE(IUNIT,70) I,(IP(J),J=IS,IW)
     WRITE(IUNIT,160) (JP(J),J=IS,IW)
     WRITE(IUNIT,160) (KP(J),J=IS,IW)
     WRITE(IUNIT,160) (LP(J),J=IS,IW)
  ENDDO

  WRITE(IUNIT,'(/10X,A)') 'PAUTO ARRAY (BY COLUMNS) :'
  DO I=1,NIMAUTO,20
     IS=I
     IW=I+19
     IF(IW.GT.NIMAUTO) IW=NIMAUTO
     WRITE(IUNIT,70) I,(IPAUTO(J),J=IS,IW)
     WRITE(IUNIT,160) (JPAUTO(J),J=IS,IW)
     WRITE(IUNIT,160) (KPAUTO(J),J=IS,IW)
     WRITE(IUNIT,160) (LPAUTO(J),J=IS,IW)
     WRITE(IUNIT,160) (ICPAUTO(J),J=IS,IW)
  ENDDO
  !
  IF(NIMIMP.EQ.0) GOTO 235
  WRITE(IUNIT,'(/10X,A)') 'IMPROPER TORSION ARRAY (BY COLUMNS) :'
  DO I=1,NIMIMP,20
     IS=I
     IW=I+19
     IF(IW.GT.NIMIMP) IW=NIMIMP
     WRITE(IUNIT,70) I,(IM(J),J=IS,IW)
     WRITE(IUNIT,160) (JM(J),J=IS,IW)
     WRITE(IUNIT,160) (KM(J),J=IS,IW)
     WRITE(IUNIT,160) (LM(J),J=IS,IW)
  ENDDO

#if KEY_CMAP==1
  IF(NIMCRT.EQ.0) GOTO 235
  WRITE(IUNIT,'(/10X,A)') 'CROSSTERM ARRAY (BY COLUMNS) :'
  DO I=1,NIMCRT,20
     IS=I
     IW=I+19
     IF(IW.GT.NIMCRT) IW=NIMCRT
     WRITE(IUNIT,70) I,(I1CT(J),J=IS,IW)
     WRITE(IUNIT,160) (J1CT(J),J=IS,IW)
     WRITE(IUNIT,160) (K1CT(J),J=IS,IW)
     WRITE(IUNIT,160) (L1CT(J),J=IS,IW)
     WRITE(IUNIT,160) (I2CT(J),J=IS,IW)
     WRITE(IUNIT,160) (J2CT(J),J=IS,IW)
     WRITE(IUNIT,160) (K2CT(J),J=IS,IW)
     WRITE(IUNIT,160) (L2CT(J),J=IS,IW)
  ENDDO
#endif 

70 FORMAT(10X,I5,5X,20I5)
160 FORMAT(20X,20I5)

235 WRITE(IUNIT,'(/10X,A)') 'NON-BONDED EXCLUSION ARRAY :'
  DO I=1,NIMINB,20
     IS=I
     IW=I+19
     IF(IW.GT.NIMINB) IW=NIMINB
     WRITE(IUNIT,70) I,(IMINB(J),J=IS,IW)
  ENDDO

  RETURN
END SUBROUTINE IMPSFPR


SUBROUTINE IMPSFWR(IUNIT,NTRANS,IMNAME,IMATTR,IMATPT, &
     SEGID,RES,RESID,IBASE,ATYPE,NICTOT, &
     IB,JB,ICBAUTO,IT,JT,KT,IP,JP,KP,LP, &
     IPAUTO,JPAUTO,KPAUTO,LPAUTO,ICPAUTO,IM,JM,KM,LM, &
#if KEY_CMAP==1
     I1CT,J1CT,K1CT,L1CT,I2CT,J2CT,K2CT,L2CT,NIMCRT, &   
#endif
     NIMEXCL,IMEXCLI,IMEXCLJ,IMEXCLT, &
     NIMBON,NIMANG,NIMDIH,NIMAUTO,NIMIMP,NSEG,NRES,NATOM)
  !
  !     THIS ROUTINE WRITES THE PSF FOR IMAGE ATOMS.
  !  It uses the new format and only includes internal energy terms.
  !  There is no atom nor exclusion information in this format.
  !
  !  The output from this format may be edited by hand and reread to
  !  allow extra, or to remove, primary-image PSF elements.
  !
  use chm_kinds
  use exfunc
  use stream
  use ctitla
  implicit none
  !
  INTEGER IUNIT,NTRANS
  character(len=*) IMNAME(*)
  INTEGER     IMATTR(*),IMATPT(*)
  character(len=*) SEGID(*),RES(*),RESID(*),ATYPE(*)
  INTEGER     IBASE(*),NICTOT(*)
  INTEGER     IB(*),JB(*),ICBAUTO(*),IT(*),JT(*),KT(*)
  INTEGER     IP(*),JP(*),KP(*),LP(*)
  INTEGER     IPAUTO(*),JPAUTO(*),KPAUTO(*),LPAUTO(*),ICPAUTO(*)
  INTEGER     IM(*),JM(*),KM(*),LM(*)

#if KEY_CMAP==1
  INTEGER I1CT(*),J1CT(*),K1CT(*),L1CT(*)
  INTEGER I2CT(*),J2CT(*),K2CT(*),L2CT(*)
  INTEGER NIMCRT
#endif 
  INTEGER NIMEXCL,IMEXCLI(*),IMEXCLJ(*),IMEXCLT(*)
  INTEGER NIMBON,NIMANG,NIMDIH,NIMAUTO,NIMIMP,NSEG,NRES,NATOM
  !
  character(len=8) IMIDI,SIDI,RIDI,ACI,XX
  character(len=8) IMIDJ,SIDJ,RIDJ,ACJ
  character(len=8) IMIDK,SIDK,RIDK,ACK
  character(len=8) IMIDL,SIDL,RIDL,ACL
  INTEGER I

    CALL WRTITL(TITLEA,NTITLA,IUNIT,0)
    I=0
#if KEY_CMAP==1
    I=NIMCRT  
#endif
    WRITE(IUNIT,40) NTRANS,NIMBON,NIMANG,NIMDIH,NIMAUTO,NIMIMP,I,NIMEXCL
40  FORMAT(/5X,'NTRANS  NIMBON  NIMANG  NIMDIH  NIMAUTO ', &
         'NIMIMP  NIMCRT  NIMEXCL',/8I8)


  WRITE(IUNIT,'(/10X,A)') 'BOND ARRAY:'
  DO I=1,NIMBON
     CALL IMATOMID(IB(I),IMIDI,SIDI,RIDI,XX,ACI, &
       SEGID,RES,RESID,ATYPE,NICTOT,IBASE,NSEG,NRES,NATOM, &
       NTRANS,IMNAME,IMATPT,IMATTR)
     CALL IMATOMID(JB(I),IMIDJ,SIDJ,RIDJ,XX,ACJ, &
       SEGID,RES,RESID,ATYPE,NICTOT,IBASE,NSEG,NRES,NATOM, &
       NTRANS,IMNAME,IMATPT,IMATTR)
     WRITE(IUNIT,61) I,IMIDI,SIDI,RIDI,ACI,IMIDJ,SIDJ,RIDJ,ACJ,ICBAUTO(I)
61   FORMAT(I7,3X,8A8,I4)
  ENDDO


  WRITE(IUNIT,'(/10X,A)') 'ANGLE ARRAY:'
  DO I=1,NIMANG
     CALL IMATOMID(IT(I),IMIDI,SIDI,RIDI,XX,ACI, &
       SEGID,RES,RESID,ATYPE,NICTOT,IBASE,NSEG,NRES,NATOM, &
       NTRANS,IMNAME,IMATPT,IMATTR)
     CALL IMATOMID(JT(I),IMIDJ,SIDJ,RIDJ,XX,ACJ, &
       SEGID,RES,RESID,ATYPE,NICTOT,IBASE,NSEG,NRES,NATOM, &
       NTRANS,IMNAME,IMATPT,IMATTR)
     CALL IMATOMID(KT(I),IMIDK,SIDK,RIDK,XX,ACK, &
       SEGID,RES,RESID,ATYPE,NICTOT,IBASE,NSEG,NRES,NATOM, &
       NTRANS,IMNAME,IMATPT,IMATTR)
     WRITE(IUNIT,70) I,IMIDI,SIDI,RIDI,ACI,IMIDJ,SIDJ,RIDJ, &
       ACJ,IMIDK,SIDK,RIDK,ACK
  ENDDO

  WRITE(IUNIT,'(/10X,A)') 'DIHEDRAL ARRAY:'
  DO I=1,NIMDIH
     CALL IMATOMID(IP(I),IMIDI,SIDI,RIDI,XX,ACI, &
       SEGID,RES,RESID,ATYPE,NICTOT,IBASE,NSEG,NRES,NATOM, &
       NTRANS,IMNAME,IMATPT,IMATTR)
     CALL IMATOMID(JP(I),IMIDJ,SIDJ,RIDJ,XX,ACJ, &
       SEGID,RES,RESID,ATYPE,NICTOT,IBASE,NSEG,NRES,NATOM, &
       NTRANS,IMNAME,IMATPT,IMATTR)
     CALL IMATOMID(KP(I),IMIDK,SIDK,RIDK,XX,ACK, &
       SEGID,RES,RESID,ATYPE,NICTOT,IBASE,NSEG,NRES,NATOM, &
       NTRANS,IMNAME,IMATPT,IMATTR)
     CALL IMATOMID(LP(I),IMIDL,SIDL,RIDL,XX,ACL, &
       SEGID,RES,RESID,ATYPE,NICTOT,IBASE,NSEG,NRES,NATOM, &
       NTRANS,IMNAME,IMATPT,IMATTR)
     WRITE(IUNIT,70) I,IMIDI,SIDI,RIDI,ACI,IMIDJ,SIDJ,RIDJ, &
       ACJ,IMIDK,SIDK,RIDK,ACK,IMIDL,SIDL,RIDL,ACL
  ENDDO
  !
  WRITE(IUNIT,'(/10X,A)') 'AUTOGEN ARRAY:'
  DO I=1,NIMAUTO
     CALL IMATOMID(IPAUTO(I),IMIDI,SIDI,RIDI,XX,ACI, &
       SEGID,RES,RESID,ATYPE,NICTOT,IBASE,NSEG,NRES,NATOM, &
       NTRANS,IMNAME,IMATPT,IMATTR)
     CALL IMATOMID(JPAUTO(I),IMIDJ,SIDJ,RIDJ,XX,ACJ, &
       SEGID,RES,RESID,ATYPE,NICTOT,IBASE,NSEG,NRES,NATOM, &
       NTRANS,IMNAME,IMATPT,IMATTR)
     CALL IMATOMID(KPAUTO(I),IMIDK,SIDK,RIDK,XX,ACK, &
       SEGID,RES,RESID,ATYPE,NICTOT,IBASE,NSEG,NRES,NATOM, &
       NTRANS,IMNAME,IMATPT,IMATTR)
     CALL IMATOMID(LPAUTO(I),IMIDL,SIDL,RIDL,XX,ACL, &
       SEGID,RES,RESID,ATYPE,NICTOT,IBASE,NSEG,NRES,NATOM, &
       NTRANS,IMNAME,IMATPT,IMATTR)
     WRITE(IUNIT,67) I,IMIDI,SIDI,RIDI,ACI,IMIDJ,SIDJ,RIDJ, &
       ACJ,IMIDK,SIDK,RIDK,ACK,IMIDL,SIDL,RIDL,ACL,ICPAUTO(I)
67   FORMAT(I7,3X,16A8,I4)
  ENDDO
  !
  WRITE(IUNIT,'(/10X,A)') 'IMPROPER TORSION ARRAY:'
  DO I=1,NIMIMP
     CALL IMATOMID(IM(I),IMIDI,SIDI,RIDI,XX,ACI, &
       SEGID,RES,RESID,ATYPE,NICTOT,IBASE,NSEG,NRES,NATOM, &
       NTRANS,IMNAME,IMATPT,IMATTR)
     CALL IMATOMID(JM(I),IMIDJ,SIDJ,RIDJ,XX,ACJ, &
       SEGID,RES,RESID,ATYPE,NICTOT,IBASE,NSEG,NRES,NATOM, &
       NTRANS,IMNAME,IMATPT,IMATTR)
     CALL IMATOMID(KM(I),IMIDK,SIDK,RIDK,XX,ACK, &
       SEGID,RES,RESID,ATYPE,NICTOT,IBASE,NSEG,NRES,NATOM, &
       NTRANS,IMNAME,IMATPT,IMATTR)
     CALL IMATOMID(LM(I),IMIDL,SIDL,RIDL,XX,ACL, &
       SEGID,RES,RESID,ATYPE,NICTOT,IBASE,NSEG,NRES,NATOM, &
       NTRANS,IMNAME,IMATPT,IMATTR)
     WRITE(IUNIT,70) I,IMIDI,SIDI,RIDI,ACI,IMIDJ,SIDJ,RIDJ, &
       ACJ,IMIDK,SIDK,RIDK,ACK,IMIDL,SIDL,RIDL,ACL
  ENDDO

  WRITE(IUNIT,'(/10X,A)') 'CROSSTERM ARRAY:'
#if KEY_CMAP==1
  DO I=1,NIMCRT
     CALL IMATOMID(I1CT(I),IMIDI,SIDI,RIDI,XX,ACI, &
       SEGID,RES,RESID,ATYPE,NICTOT,IBASE,NSEG,NRES,NATOM, &
       NTRANS,IMNAME,IMATPT,IMATTR)
     CALL IMATOMID(J1CT(I),IMIDJ,SIDJ,RIDJ,XX,ACJ, &
       SEGID,RES,RESID,ATYPE,NICTOT,IBASE,NSEG,NRES,NATOM, &
       NTRANS,IMNAME,IMATPT,IMATTR)
     CALL IMATOMID(K1CT(I),IMIDK,SIDK,RIDK,XX,ACK, &
       SEGID,RES,RESID,ATYPE,NICTOT,IBASE,NSEG,NRES,NATOM, &
       NTRANS,IMNAME,IMATPT,IMATTR)
     CALL IMATOMID(L1CT(I),IMIDL,SIDL,RIDL,XX,ACL, &
       SEGID,RES,RESID,ATYPE,NICTOT,IBASE,NSEG,NRES,NATOM, &
       NTRANS,IMNAME,IMATPT,IMATTR)
     WRITE(IUNIT,70) I,IMIDI,SIDI,RIDI,ACI,IMIDJ,SIDJ,RIDJ, &
       ACJ,IMIDK,SIDK,RIDK,ACK,IMIDL,SIDL,RIDL,ACL
     CALL IMATOMID(I2CT(I),IMIDI,SIDI,RIDI,XX,ACI, &
       SEGID,RES,RESID,ATYPE,NICTOT,IBASE,NSEG,NRES,NATOM, &
       NTRANS,IMNAME,IMATPT,IMATTR)
     CALL IMATOMID(J2CT(I),IMIDJ,SIDJ,RIDJ,XX,ACJ, &
       SEGID,RES,RESID,ATYPE,NICTOT,IBASE,NSEG,NRES,NATOM, &
       NTRANS,IMNAME,IMATPT,IMATTR)
     CALL IMATOMID(K2CT(I),IMIDK,SIDK,RIDK,XX,ACK, &
       SEGID,RES,RESID,ATYPE,NICTOT,IBASE,NSEG,NRES,NATOM, &
       NTRANS,IMNAME,IMATPT,IMATTR)
     CALL IMATOMID(L2CT(I),IMIDL,SIDL,RIDL,XX,ACL, &
       SEGID,RES,RESID,ATYPE,NICTOT,IBASE,NSEG,NRES,NATOM, &
       NTRANS,IMNAME,IMATPT,IMATTR)
     WRITE(IUNIT,71) IMIDI,SIDI,RIDI,ACI,IMIDJ,SIDJ,RIDJ, &
       ACJ,IMIDK,SIDK,RIDK,ACK,IMIDL,SIDL,RIDL,ACL
  ENDDO
#endif 

  WRITE(IUNIT,'(/10X,A)') 'NONBOND EXCLUSION ARRAY:'
  DO I=1,NIMEXCL
     CALL IMATOMID(IMEXCLI(I),IMIDI,SIDI,RIDI,XX,ACI, &
       SEGID,RES,RESID,ATYPE,NICTOT,IBASE,NSEG,NRES,NATOM, &
       NTRANS,IMNAME,IMATPT,IMATTR)
     CALL IMATOMID(IMEXCLJ(I),IMIDJ,SIDJ,RIDJ,XX,ACJ, &
       SEGID,RES,RESID,ATYPE,NICTOT,IBASE,NSEG,NRES,NATOM, &
       NTRANS,IMNAME,IMATPT,IMATTR)

     WRITE(IUNIT,72) I,IMIDI,SIDI,RIDI,ACI,IMIDJ,SIDJ,RIDJ, &
       ACJ,IMEXCLT(I)
  ENDDO

70 FORMAT(I7,3X,16A8)
71 FORMAT(10X,16A8)
72 FORMAT(I7,3X,8A8,I5)

  RETURN
END SUBROUTINE IMPSFWR

SUBROUTINE IMPSFRD(IUNIT,NTRANS,IMNAME,IMATTR,IMATPT, &
     SEGID,RES,RESID,IBASE,ATYPE,NICTOT, &
     IB,JB,ICBAUTO,IT,JT,KT,IP,JP,KP,LP, &
     IPAUTO,JPAUTO,KPAUTO,LPAUTO,ICPAUTO,IM,JM,KM,LM, &
#if KEY_CMAP==1
     I1CT,J1CT,K1CT,L1CT,I2CT,J2CT,K2CT,L2CT,NIMCRT, &   
#endif
     NIMBON,NIMANG,NIMDIH,NIMAUTO,NIMIMP,NSEG,NRES,NATOM,QAPPE)
  !
  !     THIS ROUTINE WRITES THE PSF FOR IMAGE ATOMS.
  !  It uses the new format and only includes internal energy terms.
  !  There is no atom nor exclusion information in this format.
  ! 
  !
  use chm_kinds
  use exfunc
  use stream
  use memory
  use image,only:MAXIMEX,NIMEXCL,IMEXCLI,IMEXCLJ,IMEXCLT
  use ctitla
  implicit none
  !
  INTEGER IUNIT,NTRANS
  character(len=*) IMNAME(*)
  INTEGER     IMATTR(*),IMATPT(*)
  character(len=*) SEGID(*),RES(*),RESID(*),ATYPE(*)
  INTEGER     IBASE(*),NICTOT(*)
  INTEGER     IB(*),JB(*),ICBAUTO(*),IT(*),JT(*),KT(*)
  INTEGER     IP(*),JP(*),KP(*),LP(*)
  INTEGER     IPAUTO(*),JPAUTO(*),KPAUTO(*),LPAUTO(*),ICPAUTO(*)
  INTEGER     IM(*),JM(*),KM(*),LM(*)

#if KEY_CMAP==1
  INTEGER I1CT(*),J1CT(*),K1CT(*),L1CT(*)
  INTEGER I2CT(*),J2CT(*),K2CT(*),L2CT(*)
  INTEGER NIMCRT
#endif 
  INTEGER NIMBON,NIMANG,NIMDIH,NIMAUTO,NIMIMP,NSEG,NRES,NATOM
  logical QAPPE
  !
  character(len=8) IMIDI,SIDI,RIDI,ACI,XX
  character(len=8) IMIDJ,SIDJ,RIDJ,ACJ
  character(len=8) IMIDK,SIDK,RIDK,ACK
  character(len=8) IMIDL,SIDL,RIDL,ACL
  INTEGER I,J,NT,NIMBONX,NIMANGX,NIMDIHX,NIMAUTOX,NIMIMPX,NIMCRTX,NIMEXCLX,ICPX
  INTEGER  GETIMATN
  EXTERNAL GETIMATN

    CALL RDTITL(TITLEB,NTITLB,IUNIT,0)

    IF(.NOT.QAPPE) THEN
       NIMBON=0
       NIMANG=0
       NIMDIH=0
       NIMAUTO=0
       NIMIMP=0
#if KEY_CMAP==1
       NIMCRT=0
#endif 
       NIMEXCL=0
    ENDIF 

    READ(IUNIT,40)
    READ(IUNIT,40)
    READ(IUNIT,40) NT,NIMBONX,NIMANGX,NIMDIHX,NIMAUTOX,NIMIMPX,NIMCRTX,NIMEXCLX
    WRITE(OUTU,40) NT,NIMBONX,NIMANGX,NIMDIHX,NIMAUTOX,NIMIMPX,NIMCRTX,NIMEXCLX
40  FORMAT(8I8)

    READ(IUNIT,40)
    READ(IUNIT,40)


  I=NIMBON
  DO J=1,NIMBONX
     READ(IUNIT,61) IMIDI,SIDI,RIDI,ACI,IMIDJ,SIDJ,RIDJ,ACJ,ICPX
61   FORMAT(10X,8A8,I4)
     I=I+1
     IB(I)=GETIMATN(IMIDI,SIDI,RIDI,ACI, &
                    SEGID,RESID,ATYPE,IBASE,NICTOT,NSEG, &
                    NTRANS,IMNAME,IMATPT,IMATTR)
     JB(I)=GETIMATN(IMIDJ,SIDJ,RIDJ,ACJ, &
                    SEGID,RESID,ATYPE,IBASE,NICTOT,NSEG, &
                    NTRANS,IMNAME,IMATPT,IMATTR)
     ICBAUTO(J)=ICPX
  ENDDO
  NIMBON=NIMBON+NIMBONX


    READ(IUNIT,40)
    READ(IUNIT,40)
  I=NIMANG
  DO J=1,NIMANGX
     READ(IUNIT,70) IMIDI,SIDI,RIDI,ACI,IMIDJ,SIDJ,RIDJ, &
       ACJ,IMIDK,SIDK,RIDK,ACK
     I=I+1
     IT(I)=GETIMATN(IMIDI,SIDI,RIDI,ACI, &
                    SEGID,RESID,ATYPE,IBASE,NICTOT,NSEG, &
                    NTRANS,IMNAME,IMATPT,IMATTR)
     JT(I)=GETIMATN(IMIDJ,SIDJ,RIDJ,ACJ, &
                    SEGID,RESID,ATYPE,IBASE,NICTOT,NSEG, &
                    NTRANS,IMNAME,IMATPT,IMATTR)
     KT(I)=GETIMATN(IMIDK,SIDK,RIDK,ACK, &
                    SEGID,RESID,ATYPE,IBASE,NICTOT,NSEG, &
                    NTRANS,IMNAME,IMATPT,IMATTR)

  ENDDO
  NIMANG=NIMANG+NIMANGX


  READ(IUNIT,40)
  READ(IUNIT,40)
  I=NIMDIH
  DO J=1,NIMDIHX
     READ(IUNIT,70) IMIDI,SIDI,RIDI,ACI,IMIDJ,SIDJ,RIDJ, &
       ACJ,IMIDK,SIDK,RIDK,ACK,IMIDL,SIDL,RIDL,ACL
     I=I+1
     IP(I)=GETIMATN(IMIDI,SIDI,RIDI,ACI, &
                    SEGID,RESID,ATYPE,IBASE,NICTOT,NSEG, &
                    NTRANS,IMNAME,IMATPT,IMATTR)
     JP(I)=GETIMATN(IMIDJ,SIDJ,RIDJ,ACJ, &
                    SEGID,RESID,ATYPE,IBASE,NICTOT,NSEG, &
                    NTRANS,IMNAME,IMATPT,IMATTR)
     KP(I)=GETIMATN(IMIDK,SIDK,RIDK,ACK, &
                    SEGID,RESID,ATYPE,IBASE,NICTOT,NSEG, &
                    NTRANS,IMNAME,IMATPT,IMATTR)
     LP(I)=GETIMATN(IMIDL,SIDL,RIDL,ACL, &
                    SEGID,RESID,ATYPE,IBASE,NICTOT,NSEG, &
                    NTRANS,IMNAME,IMATPT,IMATTR)
  ENDDO
  NIMDIH=NIMDIH+NIMDIHX


  READ(IUNIT,40)
  READ(IUNIT,40)
  I=NIMAUTO
  DO J=1,NIMAUTOX
     READ(IUNIT,67) IMIDI,SIDI,RIDI,ACI,IMIDJ,SIDJ,RIDJ, &
       ACJ,IMIDK,SIDK,RIDK,ACK,IMIDL,SIDL,RIDL,ACL,ICPX
67     FORMAT(10X,16A8,I4)
     I=I+1
     IPAUTO(I)=GETIMATN(IMIDI,SIDI,RIDI,ACI, &
                    SEGID,RESID,ATYPE,IBASE,NICTOT,NSEG, &
                    NTRANS,IMNAME,IMATPT,IMATTR)
     JPAUTO(I)=GETIMATN(IMIDJ,SIDJ,RIDJ,ACJ, &
                    SEGID,RESID,ATYPE,IBASE,NICTOT,NSEG, &
                    NTRANS,IMNAME,IMATPT,IMATTR)
     KPAUTO(I)=GETIMATN(IMIDK,SIDK,RIDK,ACK, &
                    SEGID,RESID,ATYPE,IBASE,NICTOT,NSEG, &
                    NTRANS,IMNAME,IMATPT,IMATTR)
     LPAUTO(I)=GETIMATN(IMIDL,SIDL,RIDL,ACL, &
                    SEGID,RESID,ATYPE,IBASE,NICTOT,NSEG, &
                    NTRANS,IMNAME,IMATPT,IMATTR)
     ICPAUTO(I)=ICPX
  ENDDO
  NIMAUTO=NIMAUTO+NIMAUTOX


  READ(IUNIT,40)
  READ(IUNIT,40)
  I=NIMIMP
  DO J=1,NIMIMPX
     READ(IUNIT,70) IMIDI,SIDI,RIDI,ACI,IMIDJ,SIDJ,RIDJ, &
       ACJ,IMIDK,SIDK,RIDK,ACK,IMIDL,SIDL,RIDL,ACL
     I=I+1
     IM(I)=GETIMATN(IMIDI,SIDI,RIDI,ACI, &
                    SEGID,RESID,ATYPE,IBASE,NICTOT,NSEG, &
                    NTRANS,IMNAME,IMATPT,IMATTR)
     JM(I)=GETIMATN(IMIDJ,SIDJ,RIDJ,ACJ, &
                    SEGID,RESID,ATYPE,IBASE,NICTOT,NSEG, &
                    NTRANS,IMNAME,IMATPT,IMATTR)
     KM(I)=GETIMATN(IMIDK,SIDK,RIDK,ACK, &
                    SEGID,RESID,ATYPE,IBASE,NICTOT,NSEG, &
                    NTRANS,IMNAME,IMATPT,IMATTR)
     LM(I)=GETIMATN(IMIDL,SIDL,RIDL,ACL, &
                    SEGID,RESID,ATYPE,IBASE,NICTOT,NSEG, &
                    NTRANS,IMNAME,IMATPT,IMATTR)
  ENDDO
  NIMIMP=NIMIMP+NIMIMPX


    READ(IUNIT,40)
    READ(IUNIT,40)
#if KEY_CMAP==1
  I=NIMCRT
  DO J=1,NIMCRTX
     READ(IUNIT,70) IMIDI,SIDI,RIDI,ACI,IMIDJ,SIDJ,RIDJ, &
       ACJ,IMIDK,SIDK,RIDK,ACK,IMIDL,SIDL,RIDL,ACL
     I=I+1
     I1CT(I)=GETIMATN(IMIDI,SIDI,RIDI,ACI, &
                    SEGID,RESID,ATYPE,IBASE,NICTOT,NSEG, &
                    NTRANS,IMNAME,IMATPT,IMATTR)
     J1CT(I)=GETIMATN(IMIDJ,SIDJ,RIDJ,ACJ, &
                    SEGID,RESID,ATYPE,IBASE,NICTOT,NSEG, &
                    NTRANS,IMNAME,IMATPT,IMATTR)
     K1CT(I)=GETIMATN(IMIDK,SIDK,RIDK,ACK, &
                    SEGID,RESID,ATYPE,IBASE,NICTOT,NSEG, &
                    NTRANS,IMNAME,IMATPT,IMATTR)
     L1CT(I)=GETIMATN(IMIDL,SIDL,RIDL,ACL, &
                    SEGID,RESID,ATYPE,IBASE,NICTOT,NSEG, &
                    NTRANS,IMNAME,IMATPT,IMATTR)

     READ(IUNIT,70) IMIDI,SIDI,RIDI,ACI,IMIDJ,SIDJ,RIDJ, &
       ACJ,IMIDK,SIDK,RIDK,ACK,IMIDL,SIDL,RIDL,ACL
     I2CT(I)=GETIMATN(IMIDI,SIDI,RIDI,ACI, &
                    SEGID,RESID,ATYPE,IBASE,NICTOT,NSEG, &
                    NTRANS,IMNAME,IMATPT,IMATTR)
     J2CT(I)=GETIMATN(IMIDJ,SIDJ,RIDJ,ACJ, &
                    SEGID,RESID,ATYPE,IBASE,NICTOT,NSEG, &
                    NTRANS,IMNAME,IMATPT,IMATTR)
     K2CT(I)=GETIMATN(IMIDK,SIDK,RIDK,ACK, &
                    SEGID,RESID,ATYPE,IBASE,NICTOT,NSEG, &
                    NTRANS,IMNAME,IMATPT,IMATTR)
     L2CT(I)=GETIMATN(IMIDL,SIDL,RIDL,ACL, &
                    SEGID,RESID,ATYPE,IBASE,NICTOT,NSEG, &
                    NTRANS,IMNAME,IMATPT,IMATTR)
  ENDDO
  NIMCRT=NIMCRT+NIMCRTX
#endif 


  IF(MAXIMEX.LT.NIMEXCL+NIMEXCLX+2) THEN
!    exclusion arrays, not allocated, or are not large enough
!  
!  first, deallocate prior list, if exists.
    IF(allocated(IMEXCLI)) THEN
      call chmdealloc('images.src','IMPATC','IMEXCLI',MAXIMEX,intg=IMEXCLI)
      call chmdealloc('images.src','IMPATC','IMEXCLJ',MAXIMEX,intg=IMEXCLJ)
      call chmdealloc('images.src','IMPATC','IMEXCLT',MAXIMEX,intg=IMEXCLT)
    ENDIF
! Now reallocate for new list
       MAXIMEX=NIMEXCL+NIMEXCLX+100
       call chmalloc('images.src','IMPATC','IMEXCLI',MAXIMEX,intg=IMEXCLI)
       call chmalloc('images.src','IMPATC','IMEXCLJ',MAXIMEX,intg=IMEXCLJ)
       call chmalloc('images.src','IMPATC','IMEXCLT',MAXIMEX,intg=IMEXCLT)
       NIMEXCL=0 ! with APPEnd option we will need to autogenerate anyway
  ENDIF

  READ(IUNIT,40)
  READ(IUNIT,40)
  I=NIMEXCL
  DO J=1,NIMEXCLX
     I=I+1
     READ(IUNIT,72) IMIDI,SIDI,RIDI,ACI,IMIDJ,SIDJ,RIDJ, &
       ACJ,IMEXCLT(I)
     IMEXCLI(I)=GETIMATN(IMIDI,SIDI,RIDI,ACI, &
                    SEGID,RESID,ATYPE,IBASE,NICTOT,NSEG, &
                    NTRANS,IMNAME,IMATPT,IMATTR)
     IMEXCLJ(I)=GETIMATN(IMIDJ,SIDJ,RIDJ,ACJ, &
                    SEGID,RESID,ATYPE,IBASE,NICTOT,NSEG, &
                    NTRANS,IMNAME,IMATPT,IMATTR)
  ENDDO
  NIMEXCL=NIMEXCL+NIMEXCLX


70 FORMAT(10X,16A8)
72 FORMAT(10X,8A8,I5)

  RETURN
END SUBROUTINE IMPSFRD

SUBROUTINE IMATOMID(ATOM,IMID,SID,RID,REN,AC, &
       SEGID,RES,RESID,ATYPE,NICTOT,IBASE,NSEGT,NREST,NATOM, &
       NTRANS,IMNAME,IMATPT,IMATTR)
    !-----------------------------------------------------------------------
    !     Given the atomnumber ATOM this routine returns the ImageID, SEGID, 
    !     RESID, RESIDUE and IUPAC atom name.
    !            BRB - 8/15/2019
    !
  use dimens_fcm
  use chutil
    !
    !
    INTEGER ATOM,NREST,NSEGT,NATOM
    CHARACTER(LEN=*) IMID, SID, RID, REN, AC
    CHARACTER(LEN=8) SEGID(*),RES(*),RESID(*),ATYPE(*)
    INTEGER IBASE(*),NICTOT(*)
    INTEGER NTRANS,IMATPT(*),IMATTR(*)
    CHARACTER(LEN=*) IMNAME(*)
    INTEGER IAT,I,ITRANS
    !
 
    IF(ATOM.LE.NATOM) THEN
       CALL ATOMID2(ATOM,SID,RID,REN,AC, &
          SEGID,RES,RESID,ATYPE,NICTOT,IBASE,NSEGT,NREST)
       IMID='PRIMARY'
    ELSE
       IAT=IMATTR(ATOM)
       CALL ATOMID2(IAT,SID,RID,REN,AC, &
          SEGID,RES,RESID,ATYPE,NICTOT,IBASE,NSEGT,NREST)
       ITRANS=1
       DO I=1,NTRANS
          IF(ATOM.GT.IMATPT(I)) ITRANS=I+1
       ENDDO
       IMID=IMNAME(ITRANS)
    ENDIF

  
    RETURN
  END SUBROUTINE IMATOMID

  INTEGER FUNCTION GETIMATN(IMID,SEG,RES,ATOM, &
                         SEGID,RESID,ATYPE,IBASE,NICTOT,NSEG, &
                         NTRANS,IMNAME,IMATPT,IMATTR)
    !-----------------------------------------------------------------------
    !     THIS FUNCTION RETURNS THE ATOM NUMBER FOR THE ATOM NAMED BY ITS
    !     IMAGE_transformation, SEGID, RESIDE, AND IUPAC NAME.
    !            BRB - 8/15/2019
    !
  use stream
  use chutil
    CHARACTER(LEN=*) ATYPE(*),RESID(*),SEGID(*)
    INTEGER NICTOT(*)
    INTEGER IBASE(*)
    CHARACTER(LEN=*) IMID,SEG,RES,ATOM
    INTEGER NSEG
    INTEGER NTRANS,IMATPT(*),IMATTR(*)
    CHARACTER(LEN=*) IMNAME(*)
    INTEGER IRES,ISEG,ISTOP,IATOM
    INTEGER IAT,JAT,I,ITRANS,IS,IQ
    !

    IAT=GETATN(SEG,RES,ATOM,SEGID,RESID,ATYPE,IBASE,NICTOT,NSEG)

    IF(IMID.EQ.'PRIMARY') THEN
       GETIMATN=IAT
    ELSE
       ITRANS=-1
       DO I=1,NTRANS
          IF(IMID.EQ.IMNAME(I)) ITRANS=I
       ENDDO
       IF(ITRANS.EQ.-1) GOTO 999
       IS=1
       IF(ITRANS.GT.1) IS=IMATPT(ITRANS-1)+1
       IQ=IMATPT(ITRANS)

       JAT=-1
       DO I=IS,IQ
          IF(IMATTR(I).EQ.IAT) JAT=I
       ENDDO
       IF(JAT.EQ.-1) GOTO 998
       GETIMATN=JAT
    ENDIF

    RETURN

998 IF(WRNLEV >= 2) WRITE(OUTU,2000) 'image atom', &
         IMID,SEG(1:idleng),RES(1:idleng),ATOM(1:idleng)
    GETIMATN=-1
    RETURN
999 IF(WRNLEV >= 2) WRITE(OUTU,2000) 'image', &
         IMID,SEG(1:idleng),RES(1:idleng),ATOM(1:idleng)
    GETIMATN=-1
    RETURN

2000 FORMAT(' *****  WARNING  ***** GETIMATN could not find the ',A, &
         ' IMID="',A,'" SEG="',A,'" RES="',A,'" ATOM="',A,'"')
  END FUNCTION GETIMATN


